6장 제목은 싱크로니제이션이에요 동기화 동기화라는 얘기를 여러분들은 이미 들었어야 돼요.
사실은 제 수업을 들었었다면 시스템 프로그래밍에서도 동기화 얘기가 나왔었고 다른 데서도 아마 나왔을 겁니다.  운영 체제에서도 아마 나왔었고 근데 시스템 프로그래밍이나 운영 체제에서 얘기가 나왔던 동기화는 한 컴퓨터 안에 있는 한 컴퓨터 안에서 돌고 있는 여러 개의 프로세스들 또는 여러 개의 트레이드들 사이에 발생할 수 있는 충돌 문제를 해결하기 위한 동기와 였다면 지금 이 수업은 분산 시스템이니까 분산 시스템에서의 동기화는 뭐냐얘도 개념은 같아요. 프로세스들 간에 또는 스레드들 간에 동기화를 해야 된다라는 거는 똑같은데 여기서는 이제 문제가 조금 더 생각해봐야 될 게 이제 한 컴퓨터가 아니고 여러 컴퓨터들에 흩어져 있는 프로세스들끼리 동기화를 시켜야 되는 문제가 있다라는 거죠. 이제 한 컴퓨터가 아니고 여러 컴퓨터니까 이 생각해야 될 사항이 더 늘어난 거예요. 더 문제가 복잡해질 수 있다. 기존에 한 컴퓨터에서 돌았을 때는 고려할 필요가 없었던 사항을 이 분산 시스템에서는 이제 동기화를 위해서 더 고려해야 할 사항이 생긴 거고요.
그런 이슈들이 어떤 것들이 있는지를 여기 6장에서 좀 크게 그나마 간단한 것들 위주로 얘기를 하려고 합니다. 그래서 동기와 개념에 대해서 처음 앞쪽에 몇 개의 슬라이드에서 설명을 하고 있죠
Synchronization in DS
분산 시스템에서의 동기화 문제다라고 하는 거는 뭐냐 하면 더 복잡하다 더 어렵다.
뭐와 비교했을 때 좀 전에 얘기했던 그냥 한 컴퓨터에서의 한 컴퓨터 동일한 컴퓨터 안에서 돌아갔던 프로세스와 쓰레드들 간의 동기화 문제보다 더 어렵다. 왜냐하면 여러 컴퓨터에 흩어진 프로세스들 간의 동기화를 시켜야 되기 때문에요. 예를 들어 여러 머신에서 지금 돌고 있는 프로세스가 여러 개가 있단 말이죠.  이 프로세스들이 프린터 프린터라고 하는 공유 리소스예요.
얘도 동기화 문제라는 게 결국은 왜 생기냐 하면 여러 개의 프로세스가 동일한 리소스를 동시에 엑세스 하려고 할 때, 충돌 문제가 생기기 때문에 그거를 풀려고 했던 거거든요.
한 컴퓨터에서도 한 컴퓨터에서 도는 여러 프로세스나 스레드들도 동기화 문제가 생긴 걸 풀어야 되는 이유가 뭐냐 하면 공유 리소스를 동시에 엑세스 하려고 할 때 가만 놔두면 문제가 발생하기 때문에 동기화 문제를 해결해야 되는 거였어요.  분산 시스템에서도 마찬가지다. 이제 여러 프로세스들이 동일한 공유의 리소스를 엑세스 하려고 하는데.  그런데 여기서는 이제 한 단계 더 나아가서 이 엑세스 하려는 프로세스들이 한 컴퓨터에 있는 프로세스가 아니고 여러 서로 다른 컴퓨터에서 도는 프로세스들이 하나의 리소스를 엑세스 하려고 한다 라는 거였죠 그래서 프린터를 액세스하려고 하는 경우가 생긴다. 근데 이제 이 분산 시스템에서의 프로세스들이 리소스를 엑세스를 하려고 할 때 동시에 경쟁 개념이라기보다는 분산 시스템에서는 협력 관계에 의해서 문제를 해결 방법은 동일해요.
개념은 동일하다. 한 컴퓨터에서 동기화를 하는 거랑 분산 시스템에서 동기를 하는 거랑 문제를 푸는 건 똑같아요. 이 프린터라고 하는 거를 여러 프로세스가 동시에 액세스를 했을 때 가만 놔두면 어떻게 돼요? 가만 놔두면
우리는 그 가만 놔뒀을 때의 경우를 생각한 적이 없어요.
왜냐하면 잘 됐기 때문에 지금 프린터 여러분들 네트워크 프린터 같은 거 쓴 적이 있는지 모르겠는데 네 네트워크 프린터가 바로 공유 프린터죠.
이 네트워크로 연결된 컴퓨터들이 있으면 다 동일한 프린터로 프린트 요청을 보내거든요.
그래서 프린터는 동시에 여러 개의 프린트 해달라는 요청을 받아요.
근데 이게 동기화 처리가 전혀 안 되면은 한 장 프린트 되는 한 장 안에 여러 프린트 요청된 사항들이 다 짬뽕돼서 막 다 출력이 될 거다.
여러 개의 문서를 출력을 동시에 했다 요청을 동시에 했다고 그러면 다 짬뽕 돼서 출력이 될 거예요.
근데 실제로는 그렇지 않죠. 프린터는 동시에 했다라고 치지만 프린터에서 그걸 또 순서대로 봤죠 순서대로 나는 동시에 요청을 한 것 같지만 프린터 입장에서는 그 요청받은 순서대로 쫙 줄을 지어가지고 받은 순서대로 차례대로 출력을 해줘요.
그래서 보면 순서대로 나오죠 섞이지 않고

그건 이미 동기화 처리가 된 거예요.
순서대로 받았다라는 것 자체가 동기화를 해결하는 가장 기본적인 솔루션이 그거거든요.
동시에 엑세스가 왔다. 그러면 이거를 동시에 하려고 하지 말고 줄을 세우란 말이죠.
먼저 요청한 놈을 먼저 처리를 해주고 그다음 그 다음 놈의 요청을 또 처리를 해주고

동시에 요청을 했더라도 어떻게든 줄을 지워가지고 이거는 이제 시리얼라이제이션이라고 얘기를 해요.
동기화를 해결하는 가장 기본 솔루션이 그겁니다. = serialization
시리얼라이제이션 같은 얘기죠. 분산 시스템에서도 똑같은 동기화 문제가 발생할 수 있다.
여기서는 서로 경쟁 관계가 아니라 협력하는 형태로
일시적으로 익스클루시브하게 엑세스를 하게 만들어서 이 문제를 풀 수 있다.
이게 그 얘기예요. 조금 그럴싸하게 얘기를 하는 게 줄을 지워서 한 번에 하나의 요청만 처리를 하게 만든다라는 거를 조금 전문용어로 익스클루시브하게 엑세스를 시키면 된다라는 거죠.
익스클루시브하다라는 얘기가 익스클루전

이런 얘기가 이게 상호 상호 배제였나요? 상호 배제 뮤추얼 익스클루션이라는 용어가 있어요.
그게 이제 상호 배제라는 말인데 이스크루시브하게 액세스를 하겠다는 말 자체가 뭐냐 하면 한 번에 한 놈만 이 리소스를 엑세스 하게 만들겠다라는 거예요.
모든 동기와 문제는 뭐 때문에 발생을 하는 거냐 하면 그냥 내비뒀기 때문에 이 리소스를 여러 놈이 동시에 막 뭔가 바꾸려고 한다든지 하는

대로 그냥 냅뒀기 때문에 발생하는 문제거든요.
그러면 그렇게 안 되게 만들면 되는 거고 그렇게 안 되게 만들려면 한 번에 한 놈만 리소스를 엑세스 할 수 있게 그게 이제 익스클루시브하게 액세스를 하게 만든다라는 거예요.
그렇게 만들면 된다. 또 다른 예제를 하나 볼까요? 동기화로 발생할 수 있는 이거는 이제 지금 위에 첫 번째 예제는 한 컴퓨터 안에 있는 프로세스들 간에도 생길 수 있는 동기화죠 그렇죠?

그리고 분산 시스템에서의 프로세스들한테도 발생할 수 있는 동기가 문제예요.
그런데 이 밑에 있는 예제는 분산 시스템에서만 추가로 고려해야 되는 동기가 문제예요.
기존에 그냥 이 프로세스들이 한 컴퓨터에서 돌았다면 고민하지 않아도 될 문제였는데 발생하지 않을 문제였는데

지금 이제 프로세스들이 여러 컴퓨터에 흩어져 있다 보니까 이런 문제까지도 고려를 해야 된다.
이게 뭐냐 봤더니 여기도 이제 프로세스가 여러 개가 있는데 그 프로세스들이 여러 머신에 흩어져 있다라는 거죠.
때때로 때때로 이 프로세스들이 서로 동의를 해야 될 필요가 생긴다라는 거예요.
분산 시스템에서는 어떤 동의를 해야 되냐 하면

오더링 어브 이벤트 어떤 이벤트가 발생을 했는데 이 이벤트가 발생한 순서 이벤트가 여러 개가 발생을 했는데 이 이벤트가 발생한 순서를 프로세스들이 서로 합의 하에 동일한 순서로 발생했다고 처리를 해야지 문제가 안 생길 텐데

이거를 동기화 작업을 하지 않으면 어떤 머신에 있는 프로세스는 이 이벤트가 벌써 먼저 발생했다라고 치고 작업을 하고 어떤 머신에 있는 프로세스는 다른 이벤트가 먼저 발생했다고 치고 작업을 하는 경우가 생길 수도 있다라는 거예요.
그냥 내비두면 그냥 내비두면 이벤트가 발생한 순서가 프로세스마다 서로 다르게 작업을 할 수 있는 문제가 생긴다.
이 문제는 조금 이따가

예를 통해서 구체적인 예를 통해서 다시 한번 볼까요? 지금 이게 뭔 소리인가 할 수도 있는데 어떤 메시지가 있단 말이죠 m1이라는 메시지가 전송이 됐고 그리고 m2라고 하는 메시지도 지금 두 개의 이벤트 이 이벤트라고 하는 거는 뭐냐 하면 메시지를 전송하는 이벤트인 거죠.
m1이라는 이 메시지가 전송이 됐고 m2라는 메시지가 전송이 됐는데

m1은 p라는 프로세스가 전송을 시킨 거고 m2라는 메시지는 q라는 프로세스가 보낸 거예요.
이 p라는 프로세스와 q라는 프로세스가 서로 다른 메시지를 각각 보낸 거죠.
그럼 이 m1과 m2라는 메시지가 전송이 됐는데 어떤 메시지가 먼저 전송이 된 거지?

라는 게 애매할 수가 있다 애매할 수가 있다? 애매할 수가 있다.
분산 시스템에서는 어떤 프로세스가 다른 프로세스가 m1 메시지를 받고 m2 메시지를 받았어요.
그럼 그냥 받은 순서대로 처리하면 되는 건가요? 다른 프로세스는 m2라는 메시지를 먼저 받고 m1이라는 메시지를 또 나중에 받을 수가 있거든요.
이렇게 받는 순서가 달라질 수 있어요.
프로세스에 따라서

메시지를 받는 순서가요 m1 받고 m2를 받았으니까 이 순서대로 처리할까? 그냥 그렇게 받는 순서대로만 처리하게 냅두면 문제가 발생할 수 있다.
서로 처리 순서가 다를 수 있기 때문에 그렇다면 m1이 먼저 보내진 거야 아니면 m2가 먼저 보내진 거야 이거를 서로 모든 프로세스들이 합의할 동의를 할 이것도 어떤 규칙이 필요하겠죠 어떤 규칙 하에서

어떤 메시지가 먼저 전송이 된 거야 라는 거를 모든 프로세스들이 합의할 수 있다면 그러면 이제 해결이 된다.
메시지마다. 가장 간단한 방법은 메시지마다 메시지를 보낸 놈이 메시지를 보낼 때 그 메시지 안에 보내는 시간 정보를

넣어서 보낼 수 있다면 그러면 간단하겠죠 그렇죠? 그럼 받는 쪽에서는 메시지를 받아서 이게 보내진 시간이 그 메시지 안에 들어가 있으니까 시간을 보면 어떤 메시지가 먼저이겠구나라는 거를 금방 캐치할 수 있잖아요.
그렇죠? 근데 지금 그게 그거 좀 이상한데요 라고 생각하는 학생들이 있을 수 있는데 그러면 이제 그게 문제라는 거죠.
그게 문제예요.

좀 이상하죠 그쵸? 지금 p라는 프로세스와 q라는 프로세스가 다른 머신에서 돌고 있는 프로세스일 수 있잖아요.
그쵸? 그렇다면 내가 보낼 때 나의 시간 정보 시간 정보는 이 피라는 컴퓨터의 시간 정보를 담아서 보낼 거고 q는 q라는 컴퓨터의 시간 정보를 담아서 보낼 거예요.
그럼 그거 두 개의 시간 정보를 비교할 수가 있나?

그게 전제가 되려면 두 컴퓨터의 시간이 지금 똑같이 돌아가고 있다라는 전제 조건이 필요하죠.
그렇죠? 이 p라는 프로세스가 도는 컴퓨터와 q라는 프로세스가 도는 컴퓨터의 시간이 지금 정확하게 일치해서 돌고 있다.
그렇다면 이제 말이 돼요. 그렇다면 그렇다면

말이 되는데 제가 전에도 잠깐 얘기했었죠 그거 맞추기 쉽지 않다고.
두 컴퓨터의 시간이 똑같이 돌아가게 만드는 게 쉽지 않은 지금 이 문제 지금 이 문제 두 번째 예제 골치 아픈 문제다.
사실 골치 아픈 문제예요. 이거 분산 시스템이 아니고 그냥 그냥 일반 시스템 싱글 스탠덜런 시스템

컴퓨터 하나 안에 있는 프로세스들 간에서는 이런 시간에 관한 문제를 고민할 필요가 없었어요.
그 프로세스들은 다 같은 시간 정보를 활용을 하기 때문에 고민할 필요가 없었는데 지금 이 분산 시스템 세계에서는 이제 시간도 맞춰야 되는가 이런 문제가 생기는 거예요.

Clock synchronization
그래서 지금 6장 동기화 문제에서 처음에 나오는 이슈가 그래서 시간을 어떻게 동기화를 해볼 거냐 이제 이 문제가 나오게 되는 거죠.
시간 지금 6장에 아마 대부분의 시간을 요 클록 싱크로니제이션 문제에 조금 할애를 할 거예요.
이것도 이제 방법이 하나가 있는 게 아니라 여러 가지 방법이 있거든요.
시간을 동기화한다라는 것 그 개념 자체가요.

오늘은 간단하다면 간단하다고 할 수 있는 클락의 동기와 문제를 어떻게 풀었는가 분산 시스템에서 많이들 고민을 했겠죠 그렇죠? 이쪽 세계에 있는 연구자들이 고민을 많이 했어요.
어떻게 시간을 맞출 거냐 시간을 동기화하지 않았을 경우에 두 컴퓨터 간에 시간을 동기화하지 않았을 경우에 생길 수 있는 문제를

Make 컴파일러의 예제를 통해서 한번 들고 있어요.
다시 여기서 구체적인 예가 또 나온다.
메이크 컴파일러는 여러분들 지금 여기서 처음인 학생도 있을 거고 본 학생도 있을 텐데 컴파일러죠 컴파일러 컴파일러인데 특히나 대량의 대규모의 프로젝트를 진행을 할 때

그러면 소스 코드 파일이 굉장히 많아지거든요.
이런 많은 소스 코드 파일을 일일이 cc나 gcc 같은 컴파일로 명령으로 컴파일을 하기가 굉장히 귀찮아져요 대규모가 되면 그래서 그거를 좀 편하게 한꺼번에 컴파일을 시켜주는 툴이에요.
메이크라고 하는 명령이 지금 여기서 메이크 사용법을 알 필요는 없는 거니까

메이크라는 컴파일러가 있다. 원래는 이제 싱글 시스템에서 도는 컴파일러예요.
메이크는 이 메이크라고 하는 놈이 어떤 식으로 돌아가는지를 여기서 설명을 하고 있는데 예를 들면 이거예요.
내가 지금 작업 중인 프로젝트에 소스 코드가 파일이 굉장히 많아요.
굉장히 많은데 그중에 내가 오늘 파일 하나를 수정을 했어요.
파일 하나를 딱 수정을 했다.

그러면 이거를 다시 컴파일을 하려면 원래 메이크를 안 썼다면 그러면 이 파일과 연계된 파일들을 또 다 작성을 해가지고 다 나열을 해야 돼요.
컴파일 할 때 이게 수정이 됐으니까 이 파일이 수정됨으로써 또 이거에 영향을 받는 파일들이 또 있을 거거든요.
그 파일들을 다 나열을 해서 다시 컴파일을 해야 되는데 이거 귀찮다.
근데 이제 메이크는 그냥 메이크 명령 한 번만 하면 돼요.
메이크라고 해서 땅 딸랑 치면 이 메이크라고 하는 컴파일러가

자동으로 찾아줘요. 파일 새로 컴파일을 해야 될 놈이 어떤 놈인지를 찾아서 그 놈만 따로 컴파일을 해줘요.
메이크는 우리가 따로 고민할 필요 없이 그 짓을 어떻게 하느냐 그 짓을 메이크가 이게 지금 다시 컴파일 해야 될 놈이구나라는 거를 어떻게 찾느냐 바로 시간 정보를 가지고 찾는다라는 거예요.
시간 정보. 어떤 시간?

지금 여기 input.c라는 예제 파일이 있는데 소스 파일이죠 이 소스 파일에 작성된 시간이 있을 거예요.
이 파일이 마지막으로 수정된 시간 정보 그거는 시스템 안에 들어가 있죠.
그렇죠? 이 파일의 속성 값을 보면

봤더니 예를 들어서 이 파일에 수정된 시간이 2151이라는 시간이더라.
그냥 간단하게 표시를 한 거예요. 시간 정보를.
이 숫자가 클수록 시간이 늦은 거죠.
뭐라고 해야 되지? 이게 값이 클수록 더 시간상으로 뒤라는 얘기죠.
뒤라는 얘기예요.

2151이라는 시간에 얘가 마지막으로 수정이 됐구나라는 걸 알고 있고 얘를 컴파일을 하면 c 파일을 컴파일을 하면 오브젝트 파일이 생성이 되거든요.
컴파일을 하고 나면 5라고 하는 오브젝트 파일이 생성이 되는데 얘도 생성된 시간이 있겠죠.
그렇죠? 그러면 이 infu.o의 시간을 봤더니 2150이더라.
21 50 시간에 컴파일이 됐네

라는 걸 아는 거죠. 그렇게 메이크라는 명령을 수행을 하면 메이크는 자기 안에 작성된 소스 파일들과 해당 오브젝트 파일의 시간 정보를 쫙 비교를 하는 거예요.
비교를 하다가 지금 여기서처럼 소스 파일은 2151 시간에 수정이 됐는데 오브젝트 파일은 21 50 시간에 컴파일이 됐었네.
저걸 보면 이제 파악이 되는 거죠.

21 50 시간에 컴파일이 된 후에 후에 21 51 시간에 건드려졌네.
소스 파일이 건드려졌네. 이게 지금 파악이 되는 거죠.
그럼 그 얘기는 뭐예요? 지금 다시 컴파일을 해야겠구나.
이 경우에 소스 코드가 건드려진 시간이 지금 마지막으로 컴파일 된 시간보다 더 뒤늦게 수정이 됐다라고 판단이 된 거죠.
판단이 되면 실제로는 사실은 수정이 안 될 수도 있어요.

우리가 그냥 이 파일 열어가지고 수정 안 하고 그냥 스페이스바만 스페이스바만 그냥 한 번 딱 했다가 백스페이스 했나 스페이스만 몇 번 두드렸다가 그냥 저장을 하면 새로 저장이 되죠.
그렇죠? 그럼 어쨌든 시간 정보는 뒤로 밀린 거죠.
새로 저장된 어쨌든 그래도 메이크는 컴파일을 한단 얘기죠.
얘가 실제 그 파일의 내용을 뜯어 봐가지고 진짜 내용이 바뀌었나 이렇게 보고 컴파일을 해주면 더 좋겠으나 그것까지는 아니더라도 시간 정보만으로 판단을 한단 말이죠.
얘가 새로 컴파일을 할 거냐 말 거냐를.

그래서 이 같은 경우에는 input c가 마지막에 confie 된 후에 다시 수정이 됐네 라고 판단을 하고 그러면 저 input .c를 메이크는 다시 컴파일을 해준다.
자동으로 이렇게 돌아가요. 메이크라고 하는 게.
그런데 이러한 메이크가 메이크라는 컴파일러가 싱글 시스템에서 돌아가는 컴파일러가 아니고

분산 시스템에서 돌아가는 하나의 서비스로서 돌아가는 컴파일러라면 컴파일러라면 이제 두 컴퓨터가 관여를 하는 거예요.
이제 두 컴퓨터가 컴퓨터가 두 개라는 얘기죠.
컴퓨터가 두 대가 있어서 한 컴퓨터는 한 컴퓨터는 input c라는


이 소스 파일을 에디팅 할 수 있는 에디터의 역할을 하는 컴퓨터가 있다.
그 다음에 메이크는 여기 따로 있단 말이죠.
파일을 해주는 컴파일을 해서 오브젝트 파일을 생성시키는 컴파일러가 돌아가는 컴퓨터가 따로 있다.
이렇게 분산돼 있는 상황이다라고 가정을 해보자.
이렇게 가정을 하는 이유는

아까처럼 메이크가 동작을 하려면 이 시간과 요 시간을 비교를 해야 되는데 지금 이제 어때요? 두 개를 비교해야 되는 그 시간에 컴퓨터가 지금 서로 다른 거죠.
그쵸? 서로 달라요. 이런 상황이라면 문제가 발생할 수 있다는 거죠.
시간 정보가 다르기 때문에 실제로 컴파일을 해야 되는 상황인데도 불구하고

시간을 봤더니 달라서 컴파일을 안 하고 그냥 넘어가는 경우가 생긴다라는 거예요.
그래서 여기 지금 이 컴퓨터에서는 input.o 가 작성된 시간이 2 1 4 4라고 지금 요 21 4 4라는 시간은 이 컴퓨터의 시간인 거죠 이 컴퓨터의 시간으로 21 4 4다.


그다음에 이제 나중에 그렇게 컴파일 하고 난 다음에 내가 에디터를 다시 열어가지고 이 컴퓨터에 있는 이 파일을 다시 열어가지고 얘를 이제 수정을 했어요.
수정을 해서 저장을 했더니 그럼 새로 저장된 시간 정보가 찍힐 텐데 그 정보가 몇으로 찍혔냐 하면 이 컴퓨터 상의 시간으로 찍혔단 말이죠.
이 컴퓨터 상에서는. 그게 2143이라는 시간으로 찍힐 수가 있다는 얘기죠.

그다음에 이제 수정했으니 이제 메이크 해야지 해서 메이크 명령을 딱 했더니 이제 이 컴퓨터에 있는 컴파일러가 실행이 시작이 돼서 또 보겠죠 여기 있는 시간과 여기 있는 시간을 비교하겠죠 비교를 했더니 컴파일 된 시간 이후에 지지 소스 코드가 마지막으로 수정된 이후에 컴파일을 했네.

그럼 얘는 컴파일 다시 할 필요 없네라고 치고 그냥 넘어간다는 얘기죠.
사실은 나중에 얘가 수정이 됐는데 뭐 때문에? 요 시간 정보가 지금 잘못돼 있는 거죠 시간 정보 시간 정보가 이렇게 두 가지로 봤더니 잘못된 거지.
이 컴퓨터만으로 봤을 때는 얘한테는 이게 맞는 시간이거든요.
얘한테서는. 근데 이걸 같이 비교를 했더니만 틀려버린다.

사실은 이 파일이 작성된 후에 수정이 된 것임에도 불구하고 이렇게 비교를 했더니 틀려버린 거란 말이죠.
그래서 메이크는 실제로 컴파일을 수행하지 않을 수 있다.

지금 그 타임 정보를 그림으로 다시 이렇게 표현을 한 거죠.
실제 실제 시간축이 이렇게 가고 있는 거죠 실제 시간 축은 이렇게 가고 있는데

그 동일한 시간에서 이 컴퓨터의 시간과 이 컴퓨터에 표시되는 시간이 서로 다르단 말이죠.
그쵸? 두 개의 컴퓨터의 시간이 안 맞기 때문에.
그래서 실제로는 이후에 소스 코드를 수정을 했음에도 불구하고 이제 메이크를 수행을 하면 이것과 이 시간 21 43과 21 4 4 시간을 비교를 하니까 컴파일할 필요 없네 뭐 하고 그냥 넘어갔더란 말이죠.

이게 제대로 돌아가려면 메이크를 제대로 돌리려면 뭘 해야 되냐 하면 두 개의 시간을 일단 맞춰야죠.
그렇죠? 얘도 21 4 2가 아니고 얘도 21 얘가 똑같이 2 1 4 4 2 1 4 5로 시간을 먼저 맞춘 다음에 메이크를 돌렸다면 그러면 이제 여기 뭐죠?

소스 코드가 수정된 시간이 21 4 3이 아니고 2 1 4 5로 찍히겠죠 그렇죠? 그럼 21 45는 21 4 4보다 나중이니까 그러면 이제 다시 컴파일을 해야겠구나 라고 판단이 들겠죠.
그렇죠? 그래서 어쨌든 이렇게 메이크라는 컴파일러가 분산 시스템 상에서 돌아가는 놈이라면 어쨌든 하나의 서비스를 돌리는 컴퓨터가 여러 개가 있다면 그 여러 개의 컴퓨터들의 안에서 돌아가는 시간은 시간 정보는 동기화를 해야겠다.
일단

그런 시간 정보 앞뒤 순서 관계를 필요로 하는 테스크를 수행을 한다면요 시간을 일단 맞춰놓고 돌려야 된다는 얘기예요.
일단 여기서는 일단 여기서는 시간을 맞추자.
근데 이제 나중에 얘기를 나중에 얘기를 미리 한다면 이거는 하나의 솔루션일 뿐이고요.
일단 두 컴퓨터의 시간을 맞추자 라는 게 이제 하나의 솔루션이 있고 그다음 솔루션이 또 있어요.
그거는 이제 뒤에 나올 텐데

로시컬 클락이라는 개념이 나올 거예요.
로시컬 클락이라는 개념을 알고 보면 단순한 개념인데 어쨌든 아무리 단순해도 처음 그거를 생각해내면 대단한 거잖아요.
그렇죠? 그걸 만든 사람도 굉장히 유명한 사람이고 뒤에 로지카 클럽 개념을 조금 이따가 아니고 좀 뒤에 다시 한번 얘기를 하도록 하죠.

그거에 앞서서 일단 그럼 컴퓨터들 간의 시간을 어떻게 동기화를 할 거냐를 먼저 보자.
이것도 의미 있는 일이니까요. 그 동기화를 위해서 일단 약간 막대기로 컴퓨터에서 돌아가는 시간 정보라고 하는 게 어떻게 발생이 되는 건지를 좀 살펴보자.
Clock synchronization : Physical clocks
우리랑 크게 상관이 있는 건 아니긴 하지만 컴퓨터에서 시간 시간 정보라는 컴퓨터마다 시계가 있죠 그쵸? 내부 시계가 있어요.

그래서 우리는 현재 시간 정보 이런 게 컴퓨터 안에서 돌아가고 있는 시기에 의해서 시간 정보를 확인할 수 있는 거고요.
그 시간 정보다라고 하는 거는 안에 타이머가 들어가 있는 거거든요.
타이머가 타이머라고 하는 건 어떻게 만들어진 거냐 하면 프리사이슬리 가공된 쿼츠 크리스털이라고 하는 놈으로 생성이 돼.
저기 에스가 아니고 사실 제트인데 제트 쿼츠

수정 서경 그 광물을 가지고 전기 자극을 주면 진동이 발생을 한대요.
그게 저도 잘은 모르는데 네 그렇대요.
그리고 그 광물을 이용해서 소자를 만든 거죠.
전기 신호를 주면 오실레이션이 발생하는 진동이 발생하는 그래서 막 헤르츠 이런 게 나오는 게 이거예요.

막 발생을 하는 거죠. 이 진동이 보니까 굉장히 주기적이더라.
주기적으로 발생을 하더라. 그래서 요 오실레이션을 가지고 카운터를 만든 거예요.
전기적으로. 그래서 매 이 진동이 몇 번 일어날 때마다 뭘 하냐 하면 뭐죠? 인터럽트를 발생을 시키는 거죠.
컴퓨터 시스템 안에서 몇 번 진동마다 인터럽트를 발생시켜서

인터럽트를 발생해서 카운트 값을 하나씩 이제 줄이는 거예요.
시간 정도 또 예를 들면 100번 진동마다 카운트를 하나씩 줄이자.
진동은 계속되니까요. 100번마다 Interrupt가 발생할 거고 100번마다 카운트 값을 하나씩 줄이고 그래서 카운트를 일정 수로 먼저 세팅을 해놓고요.
얘를 돌리는 거죠. 신호를 딱 전기를 주면 이제 오실레이션이 발생하고 그러면 어떻게 돼요? 주기적으로 인터럽트가 발생을 하는 거죠.
주기적으로.

주기적으로 인터럽트가 발생해서 그래서 몇 번 인터럽트가 발생을 하면 그 시간 몇 번이 interrupt가 발생할 때까지의 시간을 1초로 하자.
1초로 하자. 그렇게 해서 시간이 돌아가고 있는 거거든요.
지금 시계가 가는 게 그 설명을 여기서 하고 있어요.

그래서 인터럽트 매 인터럽트 걸릴 때마다 카운트를 이제 하나씩 줄이고 인터럽트가 몇 번 쌓이고 나면 그때까지 걸린 시간은 1초라고 치자 라고 이제 그런 식으로 컴퓨터가 돌아가고 있는 거죠.
컴퓨터 안에서의 시계가. 그래서 매 인터럽트를 한 번에 클락틱이라고 표현을 해요.
클락틱 한 번의 클락 한 번에 인터럽트가 발생할 때마다 그런데 이러한

이 쿼츠 크리스털이라고 하는 놈이 이거를 이제 컴퓨터마다 다 소자들을 다 컴퓨터 모델마다 가지고 있을 텐데 그럼 이 놈이 가지고 있는 이 오실레이션 주기가 다 똑같냐 그게 아니라는 거죠.
그렇죠? 컴퓨터마다 이게 다르기 때문에 그래서 시간이 다 다르게 흘러가는 거예요.
이게 다 다르니까 이걸 어떻게 똑같이 해줄 수가 없을까 그걸 막 고민을 했겠죠.
그렇죠? 그러면 이제 가공을 굉장히 정밀하게 해야겠죠 그렇죠?

굉장히 정밀하게 동일하게 가공을 하더라도 이 물질 광물 자체의 속성상 또 안에 또 다 다르잖아요.
그렇죠? 똑같이 가공을 하더라도 안의 속성이 다르기 때문에 또 이 진동수가 달라질 수가 있는 거거든요.
그래서 컴퓨터마다 다 다르다. 이 만든 소자는 다 똑같더라도 그 안에 돌아가는 진동수가 다 조금씩 차이가 있기 때문에 컴퓨터마다 시간 정보가 다 다른 거예요.
그래서 타임 difference가 생길 수밖에 없다.

다 똑같이 정확하게 똑같은 프리퀀시로 돌아간다라는 거를 보장할 수가 없다라는 거예요.
지금 이 컴퓨터 안에 돌아가는 시기에 가지고는요.
그리고 그러한 디퍼런스 시간상의 디퍼런스를 차이를 clock skew라고 얘기를 하기도 한다.
클록스키가 발생한다는 거죠. 그런데 우리는 전 세계적으로 보면 표준 시간 정보가 있죠.
그렇죠? 표준 시간 정보. 우리가 레퍼런스 할 수 있는

표준 시간 정보가 있어요. 그게 뭐예요? 우리 utc라고 들어봤죠 그렇죠? utc라는 색의 표준 시가 있죠 우리 웹 브라우저 띄워가지고 지금 현재 시간 이런 거 치면 현재 표준 시간 정보 치면은 딱 지금 막 돌아가고 있는 게 나오죠.
그렇죠? 그러면 여러분들이 웹 브라우저 상에서 보는 지금 현재 표준 시는 정확한 시간 정보일까요? 아닐까요?

대충 정확한 시간 정도 대충 완전히 정확한 시간 정도가 아니고 왜? 지금 웹브라우저 상에서 보는 시간 정보는 어딘가에서 네트워크을 타고 날아온 시간 메시지를 출력을 하는 거잖아요.
이 딜레이를 고려를 해야 돼요. day 트랜스미션 딜레이를 고려를 해야 된다.

분산 시스템에서 시간의 동기화를 맞추기가 까다롭다라고 하는 게 바로 그것 때문에 그래요.
시간. 그러면 우리가 컴퓨터 시간을 정확하게 맞추려면 생각할 수 있는 방법은 뭐예요? 그럼 아까 지금 표준 시처럼 지금 3개 표준 시 지금 정확하게 모든 사람이 레퍼런스 할 수 있는 그 시간

에게 다 맞추자. 모든 컴퓨터의 시간 정보를 전 세계 표준 시 정보에 다 맞추자라는 거죠.
그럼 얘한테 물어봐야지. 지금 지금 몇 시예요라는 걸 물어봐서 그걸 받아서 출력을 하면 똑같지 않겠느냐인데 여기서 이렇게 보내줄 때까지 걸리는 시간 그 시간까지 고려를 해야 된다라는 거죠.
그렇죠? 근데 그 딜레이도 사실은 다 다르거든요.
딜레이가

딜레이가 다 달라서 그것도 맞추기가 이렇게 쉽지 않아요.
그래서 그래서 그래요. 그래서 모든 컴퓨터들 간의 시간이 이게 초 단위로는 어떻게 지금 보면 딱 맞게 돌아 돌리게 할 수는 있을지 몰라도요.
mil 세커드 나노 세컨드 단위까지로 보면은 맞추기가 쉽지가 않아요.
맞추기가 쉽지 않고

그래서 보면 우리 컴퓨터 상에서 보면 어때요? 한 번씩 여러분들 처음에 윈도우가 요즘에 그런가요? 설치하고 나면 시간을 세팅하는 게 여러분들 나중에 가서 한번 보세요.
시간 정보 제어판에 가서 시간과 관련된 메뉴에 보면 요즘에는 그게 있어요.
인터넷 시간과 동일하게 맞추기 그런 옵션이 있어가지고 그 버튼 한 번 누르면 조금 이따가 시간이 싹 바뀌죠 그게 뭐냐 하면

세계 표준시 값을 인터넷에서 받아와가지고 그 시간으로 맞추는 거죠.
맞추 그러면 그 순간은 맞을 수는 있어요.
맞을 수 있는데 그다음에 돌아가는 거는 로컬에서 돌아가죠 로컬.
이 오실레이션에 의해서 돌아가기 때문에 또 어느 정도 시간이 지나가고 나면 또 어그러지겠죠 시간이 더 빨리 가거나 늦게 가거나 할 거기 때문에 그래서 주기적으로 또 막 맞춘다든지 막 이런 작업이 필요해요.
간단한 문제가 아니다.

Standart solar time
스탠다드 타임은 어떻게 측정을 했느냐 전 세계에서 맞추려고 하는 옛날에 이제 솔라 타임이라고 측정을 했었대요.
솔라 타임이니까 해를 기준으로 하루의 길이를 측정을 한 거죠.
옛날에는 어떤 방식으로 측정을 했냐 하면 태양, 태양이 매일 떴다 지니까요.
사실은 지구가 도는 거긴 하지만 그래서

정확한 방법은 좀 찾아봐야겠지만 대략적인 아이디어는 그거예요.
해가 제일 머리 꼭대기에 왔을 때 그때를 이제 기준으로 보는 거죠.
이걸 어떻게 잴 거야 그건 또 다른 문제이긴 하지만 해가 제일 높이 떴을 때를 딱 그때 시간을 딱 재고 그때의 순간 그다음에 한 바퀴 돌아가지고 그다음 날 그다음 날 또 가장 높은 곳에 위치할 때까지의 시간

그게 하루죠 하루 그렇죠? 하루가 딱 지날 때의 그 타이밍을 어떻게 볼 거냐 해가 높이 떴을 때 그 다음 날 해가 그 지점을 지나갈 때까지의 시간을 하루라고 보고 그 전체의 시간을 8만 6,400으로 나눈 거를 1초라고 하자 라고 정했대요.

하루 24시간이라고 하는 게 그걸 초로 치면 8만 6,400초인가 보죠 그렇겠죠? 그래서 전체 하루의 길이를 8만 6,400으로 딱 나눈 그 한 시간의 길이를 1초라고 하자 라고 이제 정하고 했었대요.

근데 그거는 정확하지가 않겠죠 그렇죠? 태양이라고 하는 거 지구의 자전과 공전을 봤을 때 태양의 뭐죠? 고도 고도도 매일 달라지고요.
시간이 다르기 때문에 이 시간이 동일하지가 않기 때문에 동일하지 않기 때문에 이걸 통해서 이 해를 통해가지고 측정한 시간 정보도 대략은 정확했지만 아주 정확하지는 않았다라는 거죠.
그렇죠?

그래서 그것만으로는 부족했기 때문에 나중에 새로 나온 게 있어요.
International Atomic Time(TAI)
어타믹타임 인터네셔널 어타믹타임 원자 시계 얘가 1948년에 개발이 됐대요 원자식이.
여기서는 이제 우리가 기존 컴퓨터에 들어가 있는 이 쿼츠 사용을 하는 게 아니고 원자 원자의 주기를 가지고 똑같은 방식으로

네 시간을 측정을 했던 거죠. 이거는 이 주기는 굉장히 정밀해돼요.
굉장히 정밀하대요. 광물의 전기 신호를 줬을 때 그거는 광물 상태에 따라서 막 달랐는데 얘는 이 원자 시계에서의 오실레이션은 굉장히 정확하대요.
이 스프리퀀시가 굉장히 정확하기 때문에 얘를 이제 표준시로 이 원자 시계에서 똑딱똑딱 하는 이 초를 표준시로 정하자라고

결정을 했대요. 그래서 이 원자 시계에서 측정한 시간과 아까 봤던 솔라 타임으로 측정한 시간과 그게 이제 계속 공존이 얼마 동안 됐던 건데 두 시간 간에 이제 차이가 생겼겠죠 그렇죠? 더 정확한 건 이 원자 시계가 더 정확했기 때문에 실제 두 개의 시계를 돌려봤더니 두 개를 돌려봤더니 원자식의 시간 정보가 3ml 세컨드 정도 이렇게 차이가 났더래요.

솔라 타임하고 3ml 세컨드면 사람 눈으로 보기에는 거의 판단하기 힘든 차이긴 하죠.
그쵸? 근데 이게 계속 쌓이면 3ml 세컨듯이 계속 매일매일 쌓이다 보면 점점점점 차이가 커지겠죠 그렇죠? 점점점점점점 커지다가 그래서 한 번씩 한 번씩 tai 원자 시계가 아니고 솔라 타임을 시간을 한번 조정해야 될 필요가 생겼대요.

더 정확한 게 있으니까 그 시간에 맞추는 거죠.
계속 놔두다가 계속 놔뒀더니 점점점점 시간 차이가 벌어지고 이게 얼마 이상 벌어지면 그랬냐 하면 800ml 세컨드 이상 벌어지면 그때마다 솔라 타임을 한 번씩 이렇게 재조정을 시켰대요.
원자 타임에 맞춰가지고 그거를 이제 leap seconds 과정이다라고 얘기를 했었대요.
d 슬라이드에 이제 그 얘기가 있는데


쭉 라인인데 위에 게 이제 원자 시계로 측정을 하는 거고 밑에 게 솔라 타임으로 측정을 한 거래요.
쭉 가다 보면 처음에는 이제 비슷하게 가죠 0 1 2 3 비슷하게 가는데 여기 좀 어그러지긴 했지만 점점점점점 보니까 어때요?

왜 이래 이거 이때쯤 보세요. 이때쯤 갈수록 원자 시계가 조금 더 빨라지고 있죠 사실은 원자 시계는 동일한데 솔라 타임이 좀 느려지고 있는 거죠.
그렇죠? 조금 느리기 때문에 시간이 지날수록 점점 더 느려지는 거죠.
그게 느려지는 게 800ml 세컨드 이상 느려지면 아니면 이 순간인 거죠.
이 순간에 한 번씩 립 세컨스 과정을 거치면

19 다음에 사실 20이어야 하는데 19 다음에 20이 아니고 그냥 20일로 딱 맞춘 거죠.
이때 한 번 싹 맞추는 거죠. 그렇죠? 그런 과정이 한 번씩 있었대요.

Universal Coordinated Time(UTC)
그래서 그러한 표준 동일한 정확하게 시간 정보를 체크하기 위한 측정하기 위한 노력 뒤에 표준시 정책을 사용을 하는 거죠.
유니버셜 코리네이티드 타임이라고 우리가 보통 utc라고 부르는 이 표준시를 사용을 하죠.
바로 이 tai

원자 시계의 정보를 이용을 해서 표준시를 마련한 거고 utc를 기준으로 전 세계 나라들이 플러스 몇 마이너스 몇 해가지고 시간 뭐죠? 시간 차이를 두고 계산을 하죠.
각 나라에서의 시간 정보를. 옛날에는 이제 utc가 아니고 gmt라는

표준시가 있었어요. gmp 그리니치 민 타임 그리니치 천문대 이쪽을 기준으로 하는 옛날에 그랬고 지금은 utc라고.
혹시 궁금한 학생들은 이것도 보면 조금 재밌는 얘기가 있었던 것 같은데 gmt에서 utc로 어떻게 변경이 되었나 이거는 그냥 재미 삼아서 나중에 한번 찾아보면 좋을 거예요.
utc라는 이름 자체도. 이것도 역사적으로 보면

말이 좀 많았다고 해요. 좀 이상하지 않아요? 유니버셜 지금 utc에 풀어쓴 시간이 어때요? 유니버셜 콜디네이티드 타임인데 그렇죠? 그럼 저거 약자라면 어떻게 돼야 돼요? 유시티가 돼야 되잖아요.
유시티. 근데 왜 유티씨지? 이상하지 않아요? 이상하죠

정치적인 문제가 많았대요. 미국식으로 하면 미국의 영어식으로 하면 유시티로 해야 하는데 이제 여러 나라가 회의를 하다 보니까 이게 프랑스 프랑스 어권 이런 데서 보면 수식어가 뒤쪽으로 달라붙어서 프랑스어로 이 유니버셜 콜리네이티드 타임을 표현하면 이게 뒤바뀐대요.
순서가. 그럼 서로 싸웠겠죠 우리 기준으로 하자 아니면 우리 기준으로 하자.
싸우다가 절충안을 낸 거죠. 썩자.

그래서 순서가 utc가 된 거래요.

그래서 이 utc 나는 지금 정확한 지금 이 순간에 정확한 시간 정보를 알고 싶다라고 한다면 이렇게 뿌리고 있대요.
National instituttve stendad time 이라고 하는 게 하는 기관에서 매번 지금 현재 원자 시계에서 측정한 그 시간 정보를

쇼트 웨이브 레디오 스테이션을 통해가지고 이렇게 전파를 쏘고 있대요. 즉, 매번 정확한 값을 전파로 쏘고 있는 것.
그 전파를 받을 수 있으면 정확한 시간 정보를 받을 수 있고 또는 인공위성을 통해가지고 받을 수 있는 받을 수도 있대요.
----------------------------------------------
그럼 이제 우리는 모든 컴퓨터에 예를 들어서 모든 컴퓨터의 시간 정보를 지금 똑같이 하고 싶은데 그러려면 누가 물어볼 대상이 있어야 될 텐데 정확한 시간 정보를 그럼 저기다가 물어보면 되겠네 utc 쪽에다가 원자시계의 정보를 알고 있는 어딘가에다가 물어봐가지고 그 시간 정보를 가지고 와서 모든 컴퓨터의 시간 정보를 그렇게 똑같이 맞추면 되겠구나라는 것까지는 이제 왔어요.

그러면 그렇게 물어봐서 시간 정보를 받아와서 출력을 그냥 하면 되느냐 아까 딜레이가 있다고 그랬죠 그렇죠? 물어본 다음에 그럼 시간 정보를 줄 텐데 자기의 시간 정보를 담아서 메시지로 보내줄 텐데 그럼 이 메시지가 전송되는 시간 동안 또 시간은 흘러갈 거고 받아서 그 메시지를 까본 그 시간은 이미 지나간 시간인 거죠.
이미 지나간 시간이기 때문에 실제로 시간을 표시를 하려면 이 전송 딜레이까지 고려를 해서 그걸 감안을 해서 이제

실제 시간을 출력을 해야 정확한 시간 정보가 된다라는 거죠.
근데 또 어려운 건 뭐예요? 이 딜레이라고 하는 게 트랜스미션 dlay라고 하는 거를 정확하게 측정하기가 또 이게 또 간단한 문제가 아니거든요.
그리고 매번 다르거든요. 컴퓨터 네트워크에서 전송되는 이 메시지의 딜레이라고 하는 게

매번 다르거든요. 이 딜레이 값이 똑같다면은 이건 간단한 문제가 될 텐데 그만큼은 그 딜레이 만큼만 더 해주면 될 텐데 이 딜레이도 매번 바뀌거든요.
그리고 그 매번 바뀌는 딜레이를 정확하게 디텍트 하기가 쉽지가 않아요.
그래서 어쨌든 100% 정확하게 하기는 힘들지만 그래도 가능한 한 정확하게 동기화를 해보자라는 노력이 있었던 거예요.
그래서 이제 시간 동기화를 어떻게 할 거냐를 한번 살펴보자.
Clock synchronization: clock synchronization algorithms
perfect world


완전한 세계 완벽한 세상에서는 완벽한 세상에서는 우리가 기준으로 삼을 시간은 이제 utc라고 봅시다.
utc를 우리가 맞춰야 되는 시간 우리의 시간은 틀렸고 이 시간에 다 맞춰야 된다라고 가정을 하는 거예요.
utc에 우리는 다 맞추도록 하자. 그 utc 맞춰야 되는 시간을 t라고 하자.

그다음에 우리가 가지고 있는 모든 컴퓨터의 컴퓨터에서 돌고 있는 시간은 이 시간이라고 치자.
Cp(t)는 이제 클락을 얘기하는 거죠.
p는 머신 머신 p라고 하는 머신에서 돌고 있는 시간 utc로는 t인데 utc 상으로는 t라는 시간인데 그 시간인데 내 피라는 컴퓨터에서 돌고 있는 해당 시간은
요 값이라는 거죠. 이 값이라는 거예요.
실제로는 그게 다를 수 있다라는 거죠.
다를 확률이 크다라는 거고. 근데 퍼펙트월드 완벽한 세상이다.
이거는 utc와 우리가 가지고 있는 모든 컴퓨터의 시간이 다 똑같다.
이게 이제 완벽한 세상이라는 거죠. 실제로는 그럴 일이 없지만 그런 완벽한 세상에서는

utc의 시간과 p라는 컴퓨터의 전 세계의 모든 p라는 컴퓨터의 시간이 다 똑같다.
그렇다는 거죠. 완벽한 세상에서는. 그리고 그거에 시간의 이게 뭐예요? 시간의 변화율.
갑자기 왜 변화율이 튀어나오지? 시간의 변화율이죠.
여기 시간의 변화율이라고 하는 거는 뭐냐 하면 dc/dt라고 돼 있는데

이거 이 변화율은 뭐냐 하면 t는 utc의 시간이라고 그랬죠 utc의 시간 변화율 대비 내 시계의 시간 변화율 간의 시간의 변화율 이 똑딱 1초라고 하는 그 시간이 변화하는 변화하는 시간인 거죠.
시간의 변화량. 그것도 퍼펙트 월드에서는

똑같겠죠 시간도 동일하게 흘러가겠죠 흘러가는 것도 동일하게 흘러갈 거기 때문에 내 시계와 utc의 시계가 동일하게 흘러갈 거기 때문에  dc/dt 이 변화율을 보면 정확하게 1이 나올 거다.
같기 때문에 변화열이 같기 때문에 일이 나올 거예요.
이게 이상적인 얘기죠. 이상적인. 근데 실제로 리얼 월드에서는 어떠냐 리얼 월드에서는 이 시간과 t가 같지도 않고

변화율도 1이 아니고 1이 아니고 1보다 크거나 1보다 작게 될 거라는 얘기죠.
실제 세계에서는. 그걸 한번 보자. 리얼 월드에서는 그냥 클락skew라고 얘기하는 이거 시간의 차이라고 그랬죠 시간의 차이를 시간의 차이를 어떻게 체크? 스키라고 하는 거는 사실은 변화량의 차이에요.
변화량의 차이 시간의 변화량의 차이 변화량의 차이라고 하는 거는 우리가 우리는 시간의 변화량이라고 하는 거를 어떻게 표현을 하냐 하면

내 시계가 지금 빨리 가 아니면 내 시계가 느려 라는 말로 표현을 하죠.
빠르다라는 거는 거는 변화량이 크다라는 거고 내 시계가 느려 라는 얘기는 변화량 값이 작다라는 얘기죠.
그쵸? 그걸 어떻게 표현을 하느냐 스키라고 하는 거를 이 값으로 이제 체크를 할 거예요.
내 시간의 변화량을

변화량에서 1을 빼자. 변화량에서 1을 빼자.
뺀 값을 한번 체크를 해보자. 1을 뺀 값이 0보다 클 수가 있고 0보다 작을 수가 있고 0일 수가 있을 거예요.
만약에 이 값이 0이라면 내 시계의 변화량은 utc의 변화량과 똑같다.
내 시계는 지금 정확하게 가고 있어.
정확하게 가는 시계야라는 말이 되는 거고 이 값이 0이라면

만약에 이 값(C’p(t)-1>0  C’p(t)>1 )이 0보다 크다면 0보다 크다는 얘기는 요 변화량 dti의 dc 값이 dc 값이 더 크다는 얘기죠.
dt보다 dtv나 dt보다 dc가 더 크기 크다라는 얘기고 그 얘기는 뭐예요? 나의 내 시계의 변화량이 더 크다.
utc의 변화량보다 내 시계가 더 빠르다는 얘기죠.
더 빠르다.

그래서 이 값이 0보다 크게 된다는 얘기는 내 시계가 지금 더 빨리 가고 있어라는 걸 나타내는 거고 반대로 0보다 작다면 내 시계가 느려.
느리게 가라는 얘기가 되는 거예요. 그래서 그걸 일단 파악을 할 수 있어야겠다.
지금 시간을 동기화를 하려면. 그래서 내가 utc 시간 대비 내 시계가 얼마나 빠른지 얼마나 느린지를 알아야 그만큼 보정을 할 거 아니에요.


변화량 말고 단순히 그냥 현재 시간의 차이를 나타낼 수도 있어요.
그냥 시간의 차이죠. 지금 현재 시간 utc의 시간 대비 내 컴퓨터의 시계의 시간이 얼마나 차이가 있는가 이건 이제 offset이라고 시간의 차이를 표시를 하기도 한다.(Cp(t)-t Offset)

그래서 만약에 어떤 시계가 있는데 시계가 있어요.

어떤 시계가 있는데 만약에 그 시계에 시간의 변화량을 체크를 해서 시간의 변화량 utc 대비 시간의 변화량을 체크를 해서 그 시간의 변화량을 봤더니 만약에 이런 조건을 만족하는 어떤 컨스턴트 값 로라고 하는 거를 찾아낼 수 있으면 찾아낼 수 있으면 그 시계는 어느 정도 이 로 값이라고 하는 그 오차 범위 안에서

오차 범위 안에서 적당히 잘 돌아가는 시계다라고 판단할 수 있겠다라는 거예요.
이게 무슨 얘기냐 하면 밑에 그래프를 보는 게 나올 것 같긴 하네요.

왼쪽 2차원 그래프로 표시를 한 건데 x 축은 뭐냐 하면 utc utc 시간이 흘러가고 있는 거예요.
지금. x 축은 utc시간 y축은 내 시계 내 시계가 흘러가고 있는 거예요.
변화 흘러가고 있는 거죠.

그래서 만약에 요 중간에 있는 요 선 요거는 이제 퍼펙트 클럽이라고 나오죠.
그 얘기는 뭐냐 하면 내 시계와 utc가 동일하게 똑같이 돌아간다면 시간의 흐름을 선으로 쫙 표시를 하면 이 라인을 따라서 갈 거란 얘기죠.
변화율이 1이기 때문에 얘가 간 만큼 얘가 똑같이 갈 거기 때문에 정사각형의 대각선을 따라서 쫙 시간이 흘러간다는 얘기죠.
2차원 그래프로 보면.

근데 실제로 좀 빠른 빨리 가는 시계다.
내가 내 시계는 utc보다 빠르다면 여기를 기준으로 위쪽 방향으로 요 위에 점선대로 흘러갈 거예요.
시간 정도가. 이거는 변화량이 1보다 큰 케이스 내 시계가 더 빨리 가는 경우 많이 빠르면 빠를수록 이게 급해지겠죠 기울기가 많이 빠르면 빠를수록 반대로 느려지면 이제 아래로 가는 거고 이렇게 빠르거나 느리거나

에 따라서 이 가운데를 기준으로 차이가 벌어질 텐데 근데 내 시계는 내 시계는 빨라지거나 느려지거나 어쨌든 빠르거나 느리거나 할 텐데 요 범위 안에서 어떤 특정 두 점선 범위 안에서 어쨌든 다 차이가 나게 가더라.
이 이상 차이가 나게 너무 빨라지거나 너무 느려지지는 않는데 너무 빠르거나 너무 느리지 않지만 이 범위 안에서 utc와 차이가 나게 흘러가더라.  이 범위가 p 값임



그런 시계라면 그래도 적당한 괜찮은 시계라는 얘기죠.
그걸 찾기 위해서 해당 요 범위 이 범위 안에 들어가는 로 값을 찾을 수 있다면 찾을 수 있다면 그걸 이제 맥시멈 드리프트 레잇 Maximum draft rate이라고 드리프트 드리프트가 이제 기준 utc를 기준으로 드리프트가 얼마나 일어났는가

얼마나 빠른가 얼마나 느린가의 그 범위를 보겠다는 거죠.
맥시 원트리프트. 그래서 그 한 개 범위를 어느 정도 범위를 알 수 있는 로 값을 찾을 수 있다면 그러한 시계는 그러한 시계는 그래도 아돌릴 만한 시계네 라고 판단을 하겠다는 거예요.
그러한 시계는 동기화 시킬 수 있겠네 라는 거예요.
그렇지 않은 시계라면

Clock synchronization : clock synchronization algorithms: Network time protocol
그렇지 않은 시계라면 동기화하기가 좀 어렵다라는 거죠.
실제로 시계로서 시계로서의 역할을 제대로 수행하지 못하는 시계라는 거죠.
너무 이렇게 가면 너무 빨라 너무 빨리 가.
시간이 한 번 맞춰놨더니 얼마 안 돼서 그냥 너무 실제 시간과 차이가 많이 나버리면 그건 사용할 수 없는 시계라는 거죠.
그렇죠? 어느 정도 오차 범위 허용할 수 있는 오차 범위 내에=maximum draft rate서 돌아가야겠다.

오늘은 이 얘기를 하다가 아마 끝날 것 같은데 다 못하고 그래서 시간을 동기화를 한번 시켜보자.
NTP 프로토콜이라고 많이 사용하는 프로토콜이 있어요.
시간을 동기화시키는 프로토콜이 있거든요.
이미 표준처럼 이 애플리케이션 레이어 프로토콜이에요.
ntp라고 하는 거 여러분들 한번 찾아보면 나올 겁니다.
ntp에서는.

그럼 어떻게 시간을 동기화를 하느냐 개념은 우리가 원래 처음에 봤던 그 개념이라고 동일해요.
동기화를 하고자 하는 컴퓨터는 묻고자 하는 대상이 있어야 돼요.
정확하게 돌아가는 그 시간 묻는 대상이 있어서 그놈한테 묻는 거예요.
시간을 지금 시간이 얼마예요라고 묻고 그러면 응답을 해주겠죠

자기가 시간 정보를 줄 거예요. 그럼 받은 그 시간 정보를 가지고 이 딜레이 값을 고려를 해서 왔다 갔다 하는 딜레이를 고려를 해서 나의 현재 시간 정보를 보정을(즉 정확한 값을 보유한 UTC 를 받아오는 과정에서 발생하는 딜레이도 보정하는것) 하는 거예요.
묻는 거예요. 나보다 정확한 시계를 갖고 있는 컴퓨터한테 물어가지고 지금 몇 시에요? 라는 걸 물어서 응답을 해주면 그 응답된 값과 딜레이

메시지를 보내는 delay 값을 다 고려를 해서 나의 시간 정보를 보정을 한다.
이 아이디어예요. 아이디어는 간단하네.
아이디어는 간단한데 그러면 그 delay라고 하는 거를 어떤 식으로 고려를 할 거야 라는 거를 지금 여기 지금 이거를 보면 된다.
이거는 뒤에 있는 슬라이드를 통해서 절차를 한번 얘기를 해보자.

지금 a라는 컴퓨터가 있고 b라는 컴퓨터 두 대가 있는 거예요.
두 대가 있고 a가 지금 묻는 컴퓨터고 b가 정확한 시기의 시간을 가지고 있는 컴퓨터다라고 보는 거예요.
b가 서버의 역할을 하는 거죠. a가 b한테 물어보는 거예요.
지금 지금 시간이 얼마예요? 몇 시에요? 물어보면 b가 a한테 응답을 해주는 과정을

지금 스텝 바이 스텝으로 쪼개가지고 지금 나타낸 거다.
x축이 이제 시간이 흘러가고 있는 거죠.
시간이 이렇게 흘러가고 있다가 a가 시간을 물어서 얻어오는 과정을 스텝 바이 스텝으로 쪼개면 어떤 과정을 거치느냐 하면 a가 자기 로컬 작업을 수행을 하다가

t1이라는 시간에 t1이라는 시간에 이제 어묻는 지금이 몇 시에요라는 걸 묻는 요청 메시지를 b한테 보낸 거죠.
b한테 보냈어요. 보내는데 이제 시간이 흘러가죠.
이게 지금 시간 이 시간은 a가 b한테 요청 메시지를 보내는 데 걸린 시간을 나타내는 거죠.
그렇죠? 이 시간이 딜레이가 걸려요.

일단

걸려서 t2라는 시간에 b가 메시지를 받았어요.
메시지를 받아서 시간을 못 내 지금 그럼 내 시간이 지금 몇 시인지를 지금 알아야겠네.
그래서 로컬 프로세싱 타임이 좀 걸려요.
나의 시간 정보를 알아내기 위해서 로컬 시간 정도가 걸려서 그래서 이제 메시지를 만들어요.
보내려고 하는 응답 메시지를 만들고 응답 메시지를 보낸 시간이 t 3이에요.
t 3이라는 시간에 응답 메시지를 보냈어요.

뭘 담아가지고 이 t 3이라는 이 시간을 담은 거예요.
난 지금 t 3이라는 시간이야라는 시간을 담아서 보냈어요.
그럼 보내는데 또 이제 이만큼의 시간이 또 걸려서 걸려서 a가 또 받았어요.
t4라는 타임에 메시지를 받았고 그 메시지를 까봤더니 까봤더니 t3이라고 하는 정보가 들어가 있다는 거죠.


지금 b라는 b 컴퓨터한테 물어봤더니 지금 시간이 t 3이라고 했네.
그런 상황인 거죠. 그럼 이러한 정보들을 가지고 이 ba의 시간 정보를 어떻게 보정을 해야 될 거냐 보정을 지금 봤더니 지금 요 실제 물리적인 시간은 이렇게 똑같이 흘러가고 있는 거죠.
그렇죠? 똑같이 흘러가고 있기 때문에 요 그래프 상에서 보니까
내가 받은 메시지 안에 t 3이라고 하는 값이 있었으니까 그쵸? 그러면 요 t 3 t 3 시점으로부터 내가 요 딜레이 값만 알면 요 딜레이 값만 알면 t 3 시점으로부터 요만큼을 더한 값이 지금 현재 시간이겠네 지금 현재 시간이겠네 정확한 시간이겠네 라는 거를 파악할 수 있을 거예요.
그런가요? 그렇겠죠

t 3 시간 플러스 요 딜레이만 그러니까 요 딜레이를 알아내면 되겠네.(T3+dTres)
요 딜레이 값이 얼마인지 요 딜레이 값은 어떻게 할까요? 여기서의 키는 이거다.
이 시간 동기화를 하기 위한 지금 키는 그래서 딜레이 값은 그럼 어떻게 구할 거야? 그래프 상에 보니까 여기 밑에 티 사고 위에 t 3이니까 t 4 빼기 t 3 하면은 저 길이가 나오지 않을까? t 4 빼기 t 3

그리고 요 딜레이나 요 딜레이나 사실은 다르겠죠 그렇죠? 사실은 다른데요.
이때 이 딜레이와 여기서 이렇게 올 때의 딜레이가 사실은 다르겠으나 지금 이 동기화 메카니즘에서는 뭐를 가정을 하고 있냐면 이 두 개의 딜레이는 비슷하다.
어차피 짧은 시간에서 왔다 갔다 할 거기 때문에 그 짧은 시간 안에서의 딜레이라고 하는 거는 이렇게 딜레이나 요렇게 딜레이나 비슷할 거다라고




가정을 해요. 가정을 하고 일단 진행을 해요.
그 가정이 없으면 할 수가 없어요. 일단 이 두 개의 딜레이는 비슷하다.
일단 가정을 둬야 되고 그다음에 다시 거꾸로 돌아와서 그러면 이 길이든 이 길이든 뭐라도 하나 알아내면 되겠는데 이걸 알기도 좀 애매하고 이걸 알기도 애매해요.
이거는 t 2에서 t를 빼면 되나 이거는 t 4에서 t 3을 빼면 되나? 이게 안 된다라는 거죠.
빼기는 이게 왜

지금 요 t1과 t4라고 하는 거는 예의 시간이거든요.
a의 시간이고 t2와 t3이라고 하는 거는 예의 시간이에요.
b의 시간이에요. b에서만 t 3에서 t2를 빼는 건 의미가 있지.
t4에서 t1을 빼는 건 의미가 있어요.
하지만 서로 지금 동기화가 시간이 동기화가 안 돼 있는 상황인데 이 시계에서 이 시간에서 이 시간을

이렇게 계산을 하는 거는 의미가 없다.
그건 의미가 없는 숫자예요. 아까 메이크 컴파일러의 예에서도 봤듯이 두 컴퓨터 간에는 지금 시간상의 동기화가 전혀 안 돼 있기 때문에 뭔가 비교를 하는 것 자체가 말이 안 된다는 거죠.
그래서 t 4에서 t 3을 뺄 수가 없어.
요 길이를 어떻게 할 거냐 근데 제가 아까 가정을 얘기했죠 요 길이와 요 길이는 비슷하다라고 일단 가정을 하자.

그래서 아이디어는 뭐냐 하면 일단 이렇게 이렇게 빼는 건 안 되기 때문에 근데 요 t 4에서 t를 빼는 거는 된다고 했죠 같은 컴퓨터에서 시간이니까.
그래서 요 길이는 나와요. 이 길이.
요 길이는 일단 나온다. t 1부터 t4까지의 전체 길이는 알 수 있어요.
계산 가능하다.

그리고 또 뭘 알 수 있냐면 얘는 알 수 있죠 얘 t 3에서 t2까지의 시간은 알 수 있죠 b가 계산을 하든지 아니면 b가 t2 정보까지 같이 보내주면 얘가 얘도 알고 얘도 알기 때문에 이 길이는 알 수 있어요.
a는 즉 a는 이 전체 길이를 계산할 수 있고 그다음에 이 길이를 계산할 수 있어요.
이 길이. 그럼 이제 다 나온 거죠

이 전체 길이에서 이 길이 빼면 되잖아요.
빼면 이 두 개의 합 길이가 나올 거 아니에요.
합의 길이가 나올 거다. 합의 길이가 나올 거니까 그거를 2로 나누자는 얘기죠.
2로. 그래서 이 길이가 두 개가 비슷하다라고 가정을 하겠다라는 거예요.
그래서 요 각각의 길이는 알 방법이 없고요.
알 방법이 없고 이 두 개를 합한 값까지는 알 수 있겠다라는 거예요.
요 전체 길이에서 이 길이만 빼면

되니까. 그러면 합한 길이가 나올 거고 그걸 2로 나누면 2로 나누면 이 하나의 delay 값이 나올 거다.
그럼 ok 그러면 delay 값을 delay 값을 알았으니까 그다음에 어떻게 해야 되지? 이제 압 슬라이드로 돌아갑니다.

압 슬라이드로 돌아가서. 그래서 t1, t2, t3, t4라고 하는 요 4개의 시간 정보를 가지고

딜레이 값을 유추할 수 있다는 거예요.
유추 근사치를 딜레이 근사치를 유추할 수 있다.
그걸 위해서는 뭘 가정을 하냐 하면 아까 a가 b로 보낼 때까지의 딜레이와 b가 a로 거꾸로 응답할 때까지의 그 딜레이 값은 비슷하다 라고 일단 가정을 한 상태에서

세타라고 하는 값을 한번 구해보자. 업셋을 한번 구해보자.
셋 옵셋은 아까 개념상에서 2개의 시간의 차이를 옵셋이라고 얘기를 했죠 그 시간의 차이를 한번 계산을 해보면 되겠다.
시간의 차이라고 하는 거를 세타라고 두고 그 세타라고 하는 거는 어떻게 될 거냐면 여기 제일 마지막 줄을 보면 이거예요.
t 3 t 3에서 이게 이제 사실 딜레이를 계산한 거예요.
요 부분이

t 3 더하기 딜레이를 한 값과 현재 나의 시간 값 그게 t4였거든요.
t4 메시지를 받았을 때 t4에서 메시지를 받았었기 때문에 다시 얘기하면 그림을 다시 보면 뭘 비교를 한 거냐면 지금 내가 메시지를 받았을 때 그러면 나의 이 시간과 이 시간과 a에서의


t 3 플러스 요 딜레이 딜레이만큼 t 3에서 딜레이를 더한 값 비슷하다는 얘기죠 t 4와 t 4와 t 3 플러스 dly 값을 비교를 하자.
그래서 뺀 거예요. 여기에서 요 t 4를 뺐어요.
뺀 값 그게 offset이라는 거고 뺐을 때 0이라면 뺀 값이 0이면

보정할 필요 없는 거네. 시간이 똑같으니까 똑같은 거고 0보다 크거나 0보다 작거나 막 이런 게 나오겠죠 그러면 그 값만큼 t4 ops 값만큼 더하거나 빼거나 하면 이제 b의 시간과 맞출 수 있겠다라는 거예요.
그거를 어떻게 지금 그럼 이 딜레이라고 하는 거를 어떻게 계산을 한 거냐를 간단한

간단한 산수를 가지고








다시 그림을 보면서 해보죠. 아까 요 요 딜레이 요 t 3에다가 더할 요 딜레이를 어떻게 구했냐 하면 일단 t 1부터 t 4까지의 시간 정보를 알아야 됐었죠 그래서 t 4에서 t를 빼야겠죠 그렇죠? t를 뺀 그 길이에서 t2부터 t 3까지의 길이를 또 빼야 되죠.
그렇죠? 여기서 뭘 빼냐 하면

t 3 마이너스 t2를 한 거를 빼서 그거를 2로 나눈 거란 얘기죠.
그걸 2로 나눈 게 바로 이 길이 또는 이 길이 얘를 정리를 하면 저 수식을 정리를 하면 이게 나온대요.

나오는지 한번 해보세요. 나중에 간단한 분수 산수 한번 해보세요.
그래서 이 식을 막 정리를 하면 이 세타라고 하는 offset(Cp(t)-t: 내 컴퓨터의 시계와 실제 정확한 시계의 차이  주의 이게 아니라 T3+delay 에서 T4를 빼는것임 , 즉 내가 정보를 받아오는 컴퓨터에서 내 컴퓨터의 시간을 빼는 것.)

내가 물은 정확한 시간 대비 내 시간 값이 차이가 얼마나 되는가를 계산한 거라고 했죠 이게 세타 값이 그 세터 값을 이렇게 이 수식으로 정리를 해서 비교를 할 수 있다.
그래서 요 값을 그래서 4개의 시간 값을 넣어서 넣으면 옵셋이 나온다는 얘기죠.
내 시계가

정확한 시간 대비 빠른지 느린지 아니면 똑같은지 값이 나온다는 거죠.
그래서 세타 값이 0이면 똑같은 거라는 거고 만약에 세탁 값이 0보다 작다라는 거는 0보다 작다라는 거는 내가 더 빠르다라는 의미가 된다.
내가 더 빨리 가고 있는 거다. 얘보다 나를 뺀 거기 때문에 0보다 작을 거면

내 쪽이 시간 값이 더 크다라는 얘기죠.
내가 더 빠르다 라는 얘기고 만약에 set 값이 of set 값이 0보다 크다는 얘기는 내가 정확한 시기보다 더 느리다라는 얘기이기 때문에 그러면 이제 시간을 세탁 값을 알았으면 보정할 수 있죠.
이제 이 세탁 값만큼 내가 더 빠르니까 빠른 경우에는 내 현재 t4라고 하는 그 시간에서 이 세탁 값만큼

빼면 될 거 아니에요. 뺀다. 만약에 느리다고 하면 이 세탁 값만큼 더 더해주면 보정이 되겠죠 그러면 시간과 동일해질 거예요.
그리고 이제 또 어쨌든 변화량이 다를 거기 때문에 지금 시간을 맞췄다 하더라도 좀 어느 정도 시간이 지나고 나면 또 차이가 발생하겠죠.
그래서 주기적으로 저 세터를 아마 체크를 해야 될 거예요.
주기적으로 얼마마다 한 번씩 체크를 해서 이 차이 값이 얼마 이상 벌어지면 보정을 한다든지

그런 과정이 필요하다. 근데 제가 아까 약간 흠칫했는데 a가 빠른 경우 내 시계가 쟤보다 더 빠르네.
그럼 늦춰야겠지 늦춰야지 하고 뭘 한다 그랬어요 세타 값에서 내 현재 값에서 세타 값을 빼면 되지 라고 했는데 흠칫했죠 지금 이 슬라이드가 그걸 설명하고 있는 거예요.
시간을 뺀다. 아무리 보정을 하는 거긴 하지만 내가 지금 지금

11시 50분을 향해 가고 있는데 지금 11시 45분인데 시간 체크를 했더니 내가 지금 1분 더 빠르네 안 되겠어.
44분으로 돌려야겠어. 그래서 45분이었다가 갑자기 11시 44분으로 바꿨다.
그건 좀 이상하다라는 얘기죠. 시간을 아무리 내가 빠르다고 지금 현재 시간에서 시간 값을 뒤로 돌리는 건 과거로 돌아가겠다라는 얘기잖아요.
시간 값을

이거는 이상하다. 이거 이상하니까 시간을 늦추는 거를 그렇게 확 시간을 빼지 말고 빼지 말고 대신 어떻게 하겠다는 얘기는 이거 다음 시간에 또 얘기를 하겠지만 내 시간이 흘러가는 값을 조금 늦추겠다라는 얘기예요.
시간의 변화량을 좀 늦추겠다. 좀 느리게 가게 하겠다는 얘기죠.
그래서 점차적으로 맞춰가도록

내가 지금 빨리 가고 빠른 거니까 시간이 빠른 거니까 그렇다고 시간 값을 빼가지고 과거로 돌아가는 건 이상하고 45분에서 갑자기 44분이 되는 건 이상하니까 그 다음 시간이 시간은 계속 흘러가게 놔두되 좀 천천히 가게 만들겠다라는 거죠.
그래서 나중에 실제 시간과 맞춰지게끔 쉽지 않죠 그렇죠? 시간 값 그냥 물어봐서 그냥 출력하면 그게 표준시 아니야 내 생각만큼 쉽지 않다.

오늘 여기까지 얘기하고 또 뒷부분에서 또 얘기를 마저 하겠습니다.



