Structured naming: The implementation of a name space: Name space distribution

서로 다른 name server 들이 전 세계에 흩어져 있고, 계층적으로 구성되어있어서 요청이 오면 자기가 담당하고 있는 부분의 name space 를 제공해 주면 되는 것이다.
Global layer 은 상대적으로 변화율(자기가 관리하고 있는 노드들의 name이 얼마나 많이 바뀌는가)이 적은 노드이기 때문에 룩업 결과를 로컬에 효과적으로 캐싱할수 있다.
Administrational layer는 lookup(naming)의 result를 가능한 한 빨리 (수 밀리초 이내)에 클라이언트로 리턴해야한다.
Managerial layer 가장 밑단에 있는 name server 인 Managerial layer은 필요에 따라서는 가용성(사용하지 못하는 문제)에 대한 문제가 상대적으로 적다. 맡고 있는 범위가 가장 작기 때문이다.  상위 레벨로 갈수록 가용성에 대한 영향이 크다.

루트 노드는 모든 노드의 정보를 다 아는게 아니라 자기와 이어져있는 하위 노드들의 정보들만 알기 때문에 전체 룩업 과정을 거치면 하위 layer의 노드들에게 물어본다음 결과를 가져오기 때문에 시간이 조금 더 걸린다. 반면 Managerial layer의 노드들은 자기가 관리하는 엔티티의 IP를 직접적으로 바로 알고 있기 때문에 즉각적으로 응답 할 수 있다.
위 표는 각 layer 들 별 특성을 정리한 것이다. Global layer 는 멈추면 안되기 때문에, replicas(복제된 개수) 가 많고, Managerial layer은 상대적으로 노드가 자주 바뀌기 때문에 client-side caching을 하지 않는다.
Structured naming : The implementation of a name space: implementation of name resolution


Iterative 하게 name resolution 하는 경우, root 부터 묻는다. 그러나 root는 자기의 하위 노드의 정보밖에 모르기에, 해당 path의 1계층아래의 노드의 주소를 반환한다. 위의 경우는 nl 의 주소를 반환한다. 그럼 클라이언트는 nl 서버에게 <vu,cs,ftp> name 을 다시 resolution 하는 것이다.

이건 recursive 한 경우이다. Client는 전체 name을 최초에 root server에게 요청하면 루트서버가 최종 address를 반환한다.
Recursive resolution
단점 : 높은 name server의 성능을 요구한다. 즉 name server 의 부하가 크다. 추가적인 부담이 너무 높아서 global layer 의 네임 서버들은 오직 interative name resolution 만 지원한다. 아래의 layer에 물어봐 이렇게 iterative 하게 동작하고 그 하위의 name server 들은 recursive 하게 동작한다.
장점 : 캐싱의 결과들은 iterative 방식에 비해 더 효과적이다. 왜냐하면 name server 에 같은 name을 쉽게 caching 할 수 있기 때문이다. 또한 클라이언트와 루트 서버 간의 communication cost 도 적다. 한번만 통신하므로.

Iterative resolution
Recursive한 방법에서 사용했던 캐싱을 iterative방식에서는 사용 불가능하다.
그러나 캐싱이 client’s name resolver 에서만 제한적으로 존재한다. 왜냐하면 왔다갔다 계속 통신을 하기 때문이다.

Name server 들은 캐싱하지 않는다. 많은 경우에 Organization 은 local 을 사용한다. 즉, 루트 서버에 resolution 하기 전에 . 우선적으로 local name server(위에서 제한적으로 캐싱한다는 Client’s name resolver) 에 캐시되어 있는 name은 없는지 부터살펴본다.
클라이언트는 매번 서로다른 name server에게 request 해야한다. 그래서 총 비용은 recursive 볻 3배는 더 든다. 위의 예시에서 3배임.
Attribute-based naming
엔티티가 가진 속성들을 나열하면 그것이 이름이 된다는 개념이다.
Structured naming은 이름으로 오직 한 entity만 지칭하도록 만들지만, Attribute-based naming은 한 이름으로 여러 entity를 지칭하도록 만들수 있다.

요게 뭐냐 이제 이름을 짓는데 이름을 짓는데 이것도 이제 플렛 네이밍이 사실 이름 짓는 방법으로서는 가장 형편 없는 거긴 하고 사실은 이름 안에 의미가 없으니까 그래서 구조적인 이름이 나온 거죠. 이름 안에 이 이름을 갖는 리소스를 찾아가는 그 절차에 대한 정보를 준 거였죠.
구조적인 이름은 그것과 유사해요. 그것과 유사하게 에티리뷰 기반 이름도 이름을 무작백이로 그냥 만드는 게 아니고 어떤 룰에 의해서 이름을 만들자. 그런데 그 룰이라고 하는 게 뭐냐 하면 내가 찾고자 하는 그 리소스의 에트리뷰트를 가지고 직접 그 리소스를 지칭할 수 있게 이름을 짓게 만들자라는 거예요.
내가 찾고자 하는 리소스의 속성 속성 속성이 하나일 수도 있고 여러 개의 속성을 가질 수도 있을 텐데 그러면 여러 개의 속성을 다 연결해서

내가 찾고자 하는 리소스는 이런 특징이 있고 이런 특징이 있는 놈이야라고 그런 특징들을 쫙 나열을 하면 그 자체가 이름이 된다라는 거죠.
그게 이제 에트리뷰트 기반의 이름이에요.
그래서 내가 찾고자 하는 이름 내가 찾고자 하는 리소스의 이름은 그 리소스의 속성을 쫙 나열하면 된다. 나열을 해서 이거를 또 던지는 거죠. 찾아줘라고 던지면 그 속성을 갖는 리소스를 누군가 찾아줄 거고요.  앞에서 봤던 구조적인 이름과 또 뒤에 뒤에 나올 테지만 특징이 뭐가 있냐 하면 아까 구조적인 이름에서는 스트럭처드 네임 네임을 하나 딱 지칭을 하면 이 패스를 갖는 리소스가 사실은 한 놈이에요. 한 놈으로 딱 매핑이 돼요. 하나 여러 놈이 아니라
근데 애트리뷰트 기반 네이밍에서는 여러 놈을 지칭하게 하나의 이름으로 여러 놈을 지칭하게 또 만들 수가 있다. 속성이라고 하는 거는 공통된 부분들이 있잖아요.
나는 요런 요런 속성을 갖는 리소스를 찾고 싶어라고 했는데 그런 속성을 갖는 놈이 하나가 아니라 여러 놈이 될 수 있는 거거든요.
속성이라고 하는 거는 공통된 부분들이 있기 때문에

그래서 공통된 특성을 갖는 여러 리소스를 한꺼번에 찾고자 할 때 그때 이제 요 애트리뷰트 기반 네이밍을 쓰면 좀 효율적으로 네이밍을 할 수 네이밍 이름을 지을 수는 있는 거고요.
근데 대신 네이밍 name resolution 절차는 structured name에비해서는 대신 좀 복잡해진다.
다 찾아야 되기 때문에 이 속성을 갖는 리소스를 다 뒤져서 찾아야 되거든요.
이것도 플랫 네이밍과 유사하게 이 속성을 갖는 리소스가 대체 어디 있는 거야를 다 뒤져야 돼요.
그래서 이걸 이그저스티브 서치라고 또 얘기를 해요.
브로드캐스트까지는 아니더라도 에트리뷰 기반 네임을 갖는 리소스를 찾는 과정 이걸 네이밍을 할 때도 뭔가 규칙이 없으면 이것도 결국엔 다 찾을 수밖에 없어요. 다 물어봐야 돼요. 브로드캐스트 비슷하게. 근데 그것도 이제 오버 에드를 좀 줄여야겠죠 줄이기 위해서 여기서도 여기서도 하이라키를 써요.
여기서도 하이라키 계층 쪽으로 뭐를
속성이라고 하는 거를 속성들을 모아가지고 조직을 만든 거예요.
계층 쪽으로 속성이라고 하는 거는 루트 격에 해당하는 속성이 있고 그 밑에 칠드런에 해당하는 속성들이 있어서 내가 찾고자 하는 리소스의 속성은 루트부터 이런 속성 이런 속성을 갖는 놈이야라고 속성들을 쫙 high layer에서 botom layer까지 쫙 속성들을 나열을 하면 이게 path가 되는 거거든요.
결국에 structured name에서와 유사하게

그러면 그 속성의 패스를 쫓아가면 해당 리소스를 똑같이 찾을 수가 있다.
전반적으로 그냥 다 이미 얘기했어요.
에트리뷰 기반 네이밍은 그런 거다. 플랫이나 스트럭처드 네임인 경우에는 unik한 그리고 location independent 한 방법으로 엔티티를 지칭을 했었는데
에트리뷰 기반 이름에서는 그렇지 않다라는 거죠.
일단 유니크하지 않을 수도 있다. 좀 전에 얘기한 것처럼 이 어떤 한 이름이 에트리비트 기반의 이름이 딱 주어졌을 때 요 이름에 해당하는 ntt가 여러 개가 될 수도 있다.
여러 개가.
스트럭처드 네임에서는 파트리 부분적으로 휴먼 프렌들리한 방법으로 이름을 짓도록 좀 애를 썼죠.
flat 네임은 완전히 애슬루틀리 휴먼 언프렌들리 한 놈이고 그거는 랜던 넘버니까 그건 봐서 모르잖아요.
근데 스트럭처드 네임만 봐도 이제 조금 그나마 휴먼 프렌들리 한 놈이고 에트리뷰 기반 네임은 좀 더 더 휴먼 프렌들리하게 이름을 지을 수 있도록 해줬다는 거예요.

그래서 사용자는 이 에트리빅 기반 이름을 어떻게 사용하냐 하냐 하면 내가 찾고자 하는 리소스 엔티티가 있을 때 그 tt가 갖는 특징 나열해주면 된다.
나열해주기만 하면 된다. 찾고자 하는 게 뭔지 뭔지를 나열만 속성만 나열해주면 된다.
그러면 그 속성이라고 하는 거를 어떻게 표현을 하는 게 좋을까가 이제 중요한 팩트가 돼요.
여기서 에트리뷰트 기반 네이밍에서는

내가 찾고자 하는 ntt의 속성이다 라고 하는 거를 어떤 식으로 표현을 하지? 그래서 대표적인 게 이거죠.
에티비유트 이름과 그 값의 페어로 속성을 표시를 한다.
속성의 이름이 있을 거고 그 속성에 해당하는 내가 찾고자 하는 놈의 값이 있을 거란 말이죠.

속성별로 값이 어떻게 되는지 에트리뷰트와 밸류의 페어로 이게 이제 하나의 속성 페어가 되는 거고 이런 놈들이 여러 개가 연결이 되겠죠 이런 놈들이 여러 개가 있어서 내가 찾고자 하는 엔티티들의 속성들을 쫙 나열을 할 수가 있는 거예요.
그래서 찾고자 하는 ntt는 보통 하나가 아닌 여러 개의 애트리뷰트들의 집합으로 표현이 될 수 있을 거고 그 자체가 이제 이름이 된다라는 거죠. 에트리뷰트 기반의 이름으로 레졸루션에 활용이 된다.
에트리뷰 기반 네이밍과 유사하게 사용이 되는 대표적인 예가 디렉토리 서비스라고 하는 게 있어요.
디렉토리 서비스

인터체인지블리 많이 사용을 한다. 애트리벳 기반 네이밍이라고 하는 거를 또는 디렉토리 서비스라고 표현을 하기도 한다.
근데 그러면 이제 속성이라고 하는 거를 속성은 대체 종류가 몇 개지? 내가 우리가 찾고자 하는 속성이다 엔티티의 속성이다라고 하는 거를 또 어떻게 정의를 할 거란 말이죠 이것도 뭔가 표준이 있으면 좋다라는 거죠.
속성이다라고 하는 거는 이런저런 종류의 속성이 있고 거기에 한해서 정의를 하도록 하자.

이런 스탠다드 룰이 없으면 또 시스템별로 제 멋대로 속성을 정의를 할 거기 때문에 찾기가 더 힘든 거고요.
그래서 속성을 속성이라고 하는 거를 어떻게 정의를 할까라는 거를 공통적으로 사용할 수 있는 룰이랄까요 프레임업이라는 게 좀 디자인이 된 게 있다.
rdf라고 하는 게 있어요. rdf.

리소스를 우리가 찾고자 하는 리소스의 특징을 디스크라이브 기술할 수 있는 특징을 기술할 수 있는 프레임 웍이에요.
그게 rdf라는 놈이 있다. 리소스 디스크립션 프레임웍이죠.
이게 그 얘기죠. 리소스를 디스크립션 할 수 있는 프레임웍.

어떻게 디스크라이브 할 거냐 하면 속성을 가지고 디스크라이브를 할 거라는 거죠.
저 rdf라는 거를 따라서 ntt의 속성을 기술할 수가 있다.
rdf에서 리소스가 어떻게 표현이 되냐 하면 trpl이라고 하는 놈으로 표현이 된다고 해요.
여기 얘가 나와 있듯이 svjet 그리고 prd키 그 다음에 avjt

주어 동사 목적어 문장으로 쓰면요. 주어 동사 목적어의 형태 세 가지 요소가 있는 거죠.
세 요소를 트리플릿 형태로 이게 이제 하나의 특성이 되는 거죠.
이게 또 여러 개가 또 있을 수도 있는 거고 이런 거죠.
주어 폴슨이다. 폴슨. 내가 찾고자 하는 엔티티는 폴슨 엔티티야.
폴슨 폴슨이고 이름이 있어.

이게 프리디킷 동사에 해당하는 놈이 되는 거죠.
펄슨인데 이름은 그리고 제일 마지막에 나오는 게 목적어 또는 valu가 되는 거죠.
vau. 이름은 앨리스야. 내가 찾고자 하는 리소스는 폴슨인데 이름이 엘리스인 놈.
그런 엔티티를 찾고 이게 바로 리소스를 리소스의 특징을 기술을 한 거죠.
이 방법으로

프리 트리플릿 형태로 기술을 해놓으면 이 정보를 가지고 이제 임 네이밍 과정을 수행을 하겠다는 거예요.
그래서 애플리케이션은 이거를 물은 거죠.
어떤 ntt를 찾고자 하는 건데 펄슨이고 이름이 앨리스로 지어진 어떤 정보를 찾고 있는 거다.

이런 식으로 하면요 스트럭처드 네이밍 시스템에서와는 달리 이 특성 에트리뷰 을 갖는 ntt를 찾을 때 찾는 오버헤드는 스트럭처드 기반 네이밍에 비해서는 더 커요.
찾는 비용은 찾는 코스트는 왜냐하면

아까도 얘기했듯이 이런 특성을 갖는 ntt라고 하는 게 유일하지 않을 수가 있거든요.
여러 놈이 있을 수 있기 때문에 다 뒤져봐야 된다.
다 뒤져봐야 된다. 스트럭처드 네임은 한 놈이니까 그 패스만 그냥 쭉 쫓아서 내려가다 보면 그냥 한 놈 만나는 놈 찾으면 땡인데 에트리 기반 네임에서는 가리키는 속성이 물론 한 놈일 수도 있는 경우도 있고 여러 놈일 수도 있다.
요 속성을 갖는 엔티티가

여러 개일 수가 있기 때문에 그때는 뒤져야 되는 범위가 더 커지는 거죠.
그래서 exhaustive search가 필요하다 라고 얘기를 해요.
그렇게 이그저스티브하게 서치를 해야 되니까 그 비용도 좀 어떻게 하면 줄일까
Attribute-based naming: Hierarchical implementations: LDAP

생각을 하다 보니 찾고자 하는 그 네임 스페이스라고 하는 거를 스트럭처드 네임과 유사하게 이 애트리뷰트 기반 이름에서도 네이밍 시스템에서도 네임 스페이스를 전체 네임 스페이스를 하이라키컬하게 구성을 해보자.
그러면 좀 더 그나마 좀 더 효율적으로 찾을 수 있을 거라는 거예요.

LDAP라고 하는 프로토콜이 저런 정책을 사용을 한다.
이건 아마 이름을 들어본 적이 있는 학생도 있을 거예요.
ldap라고 하는 프로토콜이 있어요.
뭐냐 하면 lightweight directory 액세스 프로토콜의 약자다.
ldap라고 하는 거는 rit wait 하다라는 거죠.
라it wait 무겁지 않고 디렉토리 엑세스 프로토콜

에트리빅 기반 네이밍은 디렉토리 서비스라고 하기도 한다고 그랬죠 애트리빅 기반 네이밍을 사용하는 프로토콜의 일종이에요.
그래서 ldap라고 하는 놈을 통해서 에트리비트 기반 네이밍에서 네임 레졸루션을 어떻게 수행을 하는지를 우리가 대신 한번 쳐다보도록 하자.
네임 밍 레졸루션을 어떻게 할 거냐 가능한 한 eggestv 설치를 좀 줄이고 이걸 어떻게 하냐 하면 ldap에서는

lam 스페이스를 하이라키카르의 계층 쪽으로 구성을 했다는 거죠.
ldap에서의 디렉토리 서비스는 레코드 디렉토리 엔트리라고 하는 레코드를 쫙 유지를 하고 있어서 여러 놈들이 여러 노드들이 분산해서 마치 strochalde namig에서 name 서버들이 여러 개 분산돼서 계층 쪽으로 구성이 돼 있는 것처럼 여기서도

디렉토리 엔트리라고 하는 놈이 찾고자 하는 노드의 정보를 관리하는 놈을 디렉토리 엔트리라고 얘기를 하는 거고 이 디렉토리 엔트리들을 노드들이 나눠서 여기서도 분산해서 관리를 하고 있다라는 거예요.
레코드들을 디렉토리 엔트리라고 하는 게 구조적인 스트럭처드 네임에서 dns 서비스에서 하나의 리소스 레코드와 매핑이 돼서

생각이 매핑해서 생각을 하면 된다라고 얘기를 하고 있어요.
하나의 리소스 레코드가 그거예요. 도메인 네임과 거기에 해당하는 아이피 어드레스 그게 이제 하나의 레코드가 되는 거죠 스트럭처드 네임에서 그것과 마찬가지로 여기서도 ldap 프로토콜에서도 어떤 속성 그 속성에 해당하는 아이피 주소 예를 들면 아이피 주소에 해당하는 레코드가 있다라는 거죠.
그걸 이제 디렉토리 엔트리라고 부른다라는 거고요.


다음 슬라이드의 이 그림에 이게 이제 하나의 예가 되는 거죠.
에트리뷰트가 ldap에서 하이라키컬하게 어떻게 구성이 되는가 보면은 구조적인 그 스트럭처드 네임하고 사실 비슷해요.
스트럭처드 네임하고 여기 왼쪽에 에트리 속성들이 이런 속성들이 있다라는 거죠.
그 속성에 해당하는 값이 이렇게 돼 있다.
이런 속성들을 갖는 엔티티를 찾겠다.
이렇게 되는 거죠. 에트리뷰 기반 이름에서는

이런 속성들을 갖는 이 표가 나타내는 속성 값을 갖는 엔티티를 내가 찾겠다라고 리퀘스트를 던지는 거죠.
트리뷰 기반 에트리뷰 기반 네이밍 시스템에 근데 그 속성이라고 하는 걸 봤더니 우리가 좀 전에 봤던 거랑 좀 비슷하다.

contrry라고 하는 속성이 있고 rcolity라는 속성이 있고 ognzation 속성이 있고 요 위에서부터 아래로 한번 좀 보세요.

이게 뭐죠? 지오그래피컬하게 큰 범위에서 작은 범위로 점점점점 좁혀들고 있어요.
여기서의 속성이라고 하는 거는 그런 지오그래피컬한 속성만 가지고 일단 하긴 했네요.
근데 나라 그다음에 지역 로컬리티라고 하지만 여기 값을 보면 암스테르담이라고 나오는 거 보니까 도시 레벨의 범위가 되겠죠 로컬리티라고 하는 게 나라 어떤 나라에 어떤 도시에

어떤 기관에 점점 범위가 좁혀들죠 그렇죠? 어떤 기관에 그 기관 안에 어떤 디파트먼트에의 어떤 서버 찾겠다라는 식으로 이것도 이제 속성을 나열하는 예 중에 하나죠.
컨트리는 nl 네덜란드고 컨트리라는 속성은 네덜란드고

그다음에 locolity 속성 값은 암스테르담이고 네덜란드의 암스테르담 도시 안에 그다음에 ogonization은 이런 대학이 있고 암스테르담에 있는 대학이 여러 개 있을 텐데 그중에 이 대학 안에 그다음에 대학 안에 또 departimet가 여러 개 있는데 organization unit은 컴퓨터 sies다.
컴퓨터 sience 과의

컴퓨터 사이언스 과에 뭘 찾냐 하면 커먼 네임 찾고자 하는 그 속성 중에 또 커먼 네임이라는 속성이 있는데 뭐냐 메인 서버.
저 암스테르담의 저 대학 안에 있는 컴퓨터 공학과에 메인 서버를 나는 찾고자 한다가 되는 거죠.
결국에는 그 속성이라고 하는 거를 해석을 해보면 저런 속성을 갖는 놈의

ip 주소를 알려달라.

속성이 이제 이런 놈들도 있죠 메일 서버도 있고 ftp 서버도 있고 웹 서버도 있대요.
그래서 이런 것까지 요청을 할 수 있겠죠.
이 속성 중에 메일 서버를 내가 알고 싶어 라고 주면 해당하는 메일 서버가 여러 개가 있네요.
여러 개. 요 놈들을 이제 다 찾아준다는 거죠.

한 놈이 아니 한 놈이 아니라 여러 놈으로 매핑이 될 수도 있더라.
그 속성을 갖는 엔티티가 여러 엔티티가 될 수도 있다라는 얘도 여기서 이제 보이고 있는 거죠.

여기 용어들이 있는데 이건 ldap라고 하는 ldap 프로토콜에서 사용하는 용어인데 뭐냐 하면 디렉토리 인포메이션 베이스 줄여서 dib라고 하는 거는 db db ldap에서 유지하는 전체 db 그 속성과 값

에트리뷰 이름과 해당하는 뭐죠? 위치 정보 어드레스 정보들의 총 집합 db db 레코드 디렉토리 엔트리의 총 집합을 dib라고 그냥 일단 부르더라.
그다음에 렐러티브 디스틴그시트 n rdn이라고 하는 용어를 사용하는데 이거는 다른 게 아니고 각각의 애트리뷰트

네이밍 에트리뷰 각각의 에트리뷰트를 이제 알디엔이라고 불러요.
아까 여기 이 표에서 요 로우 하나가 하나의 rdn이라고 얘기를 하는 거예요.
하나의 알디엔 알디엔 여러 개가 이제 모여 있는 거죠.

그래서 여기 앞에 그림에서 봤던 요 표로 나와 있던 요 에트리뷰트 이름을 이런 식으로 표현을 할 수 있다라는 거예요.
이렇게 여기 슬래시로 에트리뷰트 별로 구분을 해놓은 거죠.
이게 이제 이름이다. 이름 에트리뷰트 이름이에요.
지금요. 속성을 갖는 ntt를 이제 찾아주겠다라는 거죠.
에티리벳 기반 네이밍 시스템에서

씨 컨트리는 nl이고 오버니제이션은 이 대학이고 오버니제이션 유닛은 컴퓨터 사이언스고 에 해당하는 놈을 찾아주세요.
마치 우리가 좀 전에 봤었던 strochald 네이밍에서 nl vu cs로 패스 이게 패스 중에 일부였죠 우리가 스트록 드 네이밍 했을 때와 유사하죠 유사한 방법이다.

근데 이제 속성이기 때문에 다른 속성이 또 사용이 될 수도 있겠죠 이때 네이밍 스페이스 찾고자 저렇게 name attribut name이 딱 주어졌을 때 그 속성을 갖는 nntt를 어떻게 찾을 거냐 아무 룰도 없으면 우리가 flatnaming에서와 유사하게 브로드캐스트를 하든지 뭘 쫙 뿌려야 되는데 그거를 그 짓은 하면 안 된다고 그랬죠

그래서 이렇게 구성을 해요. 디렉토리 인포메이션이라고 하는 거를 트리 형태로 계층 쪽으로 구성을 한다.
그래서 찾고자 하는 메인 스페이스를 하이라키컬하게 트리 형태로 일단 딱 구성을 해놓고 루트부터 이제 이 속성에 따라서 패스를 쫓아가겠다라는 거죠.

dit라고 하는 디렉토리 인포메이션 트리는 이 전체 디렉토리 인포메이션 베이스 db를 트리 형태로 조직을 시켜놓겠다라는 거예요.
좀 더 효율적으로 찾기 위해서 그래서 네이밍 그래프라고 엘디에이피의 네이밍 그래프라고 표현을 하기도 하는데

요 위에 요 슬라이드의 그림처럼 이게 이제 DIT

디렉토리 인포메이션 트리의 일부를 이제 나타낸 거죠.
일부를 나타내면서 루트부터 주어진 속성에 따라서 pass를 쫓아내려가면 해당 ntt를 찾을 수 있다는 거예요.
컨트리에 해당하는 엣지가 또 여러 개가 있겠죠 nl에 해당하는 엣지만 보여주고 있는 거지만 여기 kr에 해당하는 엣지도 있을 거고요.
그렇죠?


다른 엣지들이 또 딴 데 있을 거예요.
nl 에지 중에 nl 안에 또 대학들이 여러 개가 있을 텐데 여러 대학을 엣지로 또 연결을 해놨을 텐데 그중에 이 대학 이 대학 안에 학과들이 여러 학과들이 있을 텐데 그중에 컴퓨터 공학과 컴퓨터 공학과 안에서도 유지되는 서버들이 여러 개가 있을 텐데 그중에

메인 서버 메인 서버 그중에 보니까 메인 서버에 호스트 네임이 스타라고 하는 놈이 있고 제피어인가 뭐 이런 놈이 있네요.
두 놈이 있네요. 그놈을 표로 다시 정리를 해놓은 거예요.
속성들을 표 형태로 정리를 한 거예요.
컨트리부터

메인 서버인데 호스트 네임이 스타인 놈 스타 놈의 아이피 어드레스는 이 놈이다.
결국에는 이게 이제 리턴이 되겠죠 찾고자 하는 엔티티의 주소는 이거야 라는 거 찾아줄 거고 이 이름을 갖는 놈의 ip 주소는 이 놈이다라는 거를 네임 레졸루션의 최종 결과로 알려주게 될 거예요.

디렉토리 s비스 에이전트(DSA)라고 하는 놈이 바로 그런 ldap 상에서 네이밍 레졸루션을 해주는 서버 네이밍 서버의 역할을 하는 놈을 이렇게 이름을 지어놨어요.
디렉토리 s비스 에이전트라고 하는 놈이 그 트리 트리를 쫙 뒤지면서 요청된 룩업 요청된 사항을 처리를 해주는 놈인 거죠 (DUA)에이전트가 요놈은 클라이언트를 얘기를 하는 거예요.
디렉토리 유저 에이전트 유저 에이전트가 룩업 리퀘스트를 날려주는 거죠.
ldap 서비스 쪽으로 이런 속성을 갖는 엔티티 좀 찾아줘라고 하면

DSA가 찾아줄 거예요. 그러면 이 클라이언트 user 에이전트가 날릴 수 있는 쿼리 쿼리죠 룩업 request라고 하는 형태가 우리가 앞에서 봤던 속성들의 연결로 쫙 하면 되는데 이제 예를 들면 이런 식의 리퀘스트를 또 날릴 수가 있어요.

형태는 좀 다르지만 결국에는 같은 놈이에요.
이것도 속성들의 나열이에요. 그쵸? 근데 여기서 한번 보면 이런 것도 날릴 수 있다라는 거예요.
우리가 Structured name에서는 할 수 없었던 쿼리를 atrivit 기반 네m에서는 할 수 있다.
예를 들면 내가 찾고자 하는 entt는 nl이고 contri는 네덜란드고 이 대학인데 올거니제이션 유닛이 스타예요.
스타. 에스터 리스크로 이렇게 표현할 수 있어요.
올거니제이션 유닛이 스타라는 얘기는 학과 모든 학과-> 즉 하나의 엔티티 뿐만 아니라 복수의 엔티티도 룩업(resolution) 가능하다.

다 얘기한다. 이거는 어? 꼭 컴퓨터 공학과 이게 아니고 나는 이 네덜란드의 이 대학 안에 있는 모든 학과에 메인 서버 값을 알고 싶어.
이렇게 쿼리를 날릴 수도 있다. 이거는 이제 모든 학과의 메인 서버를 다 뒤져야겠죠 그렇죠? dit트리에서 일단 대학까지는 유일한 패스로 쫙 내려오고 이 대학에 학과들이 패스가 여러 개가 있을 텐데 그 패스를 한 번씩 다

돌아봐야 되는 거죠. 이제 학과별로 요기에 메인 서버 요 학과의 메인 서버 요 학과의 메인 서버를 다 뒤져야 된다.
이 ldap 서버가 어쨌든 이런 식으로 주면 이제 설치 코스트는 늘어날 거예요.
코스트 설치하는 비용은 늘어나는데 대신 여러 결괏값을 알려줄 수는 있을 거다.
클라이언트에게. 그래서 이렇게 dire토리 ldap 등 atrivit 기반 네이밍ig 시스템에서

drectory savis에서 설치 비용이 expansive 하다.
일반적으로 여기 비싼 이유 중에 하나가 뭐냐 하면 이런 것 때문에 request로 날아온 속성에 해당하는 ntt가 유일하지 않을 수 있기 때문에 좀 뒤져봐야 되는 경우가 생기는 거죠.

위에 예처럼 발음을 어떻게 하는지 모르겠네요.
vlg 대학인가? 이게 뭔지 모르겠네.
이 대학 안에 있는 모든 메인 서버를 찾고자 한다.
나는 이제 이런 거를 그럼 스트럭처드 네이밍 방법에서는 이런 거를 리퀘스트를 어떻게 날려야 되지? 스트럭처드에서는 어렵다라는 거죠.
이 대학에 있는 모든 메인 서버를 내가 찾고자 한다.

이걸 스트라드 네이밍이나 플랜 네이밍을 가지고서는 당장 안 떠올라요.
이걸 어떻게 해야 될지 리퀘스트를 어떻게 날려야 될지 모르겠어요.
스트럭처드 네임이나 플랜 네일 때는 내가 찾고자 하는 리소스의 네임을 일단 알아야 돼요.
그렇죠? 네임을 일단 알고 이걸 좀 레졸루션 해주세요라고 던지는 거다.
근데 에트리뷰 기반 네이밍에서는 이름 자체에 이름 자체가 속성으로 이루어진 거기 때문에 그 속성이라고 하는 거를 조금 abstract하게 표현을 할 수도 있는 거거든요.
그래서 내가 정확한 이름은 아니지만

요런 요런 속성을 갖는 엔티티를 찾고 싶은데 이런 게 이제 가능하다라는 거죠.
정확한 이름을 모르더라도 일부 속성만 가지고도 그러면 그 속성을 갖는 엔티티를 찾겠다.
이렇게 리크레스를 날릴 수가 있다라는 거죠.
설치 코스트는 좀 크다 하더라도요.

Attribute-based naming: Decentralized implementations: Mapping to DHT
이제 마지막 타픽인데요. 이게 마지막 네이밍의 마지막 타픽인데 이렇게 에트리비트 기반 네이밍을 우리가 ldap라고 하는 프로토콜을 사용해서 뭔가 서버가 있다고 그랬죠 그 서버 쪽에 요런 요런 속성을 갖는 ntt를 좀 찾아주세요라고 나는 서버한테 물어본 거죠.
그렇죠? LDAP이거는 소위 얘기하는 우리가 분산 시스템에서의 아키텍처로 보면 센트럴 라이스 아키텍처

롤에서 서비스를 요청을 한 거예요. 서버한테 서버가 여러 개는 있더라도 일단 서버한테 물어보는 거죠.
나는 나는 물어볼 대상이 있는 거죠.
그쵸? 서버한테 요런 요런 속성을 갖는 엔티티 좀 찾아줘 라고 atroit 기반 네이밍ig 시스템에 물어본 건데 이것도 dsentralize 하게 에트리빅 기반 네이밍 시스템을 구축을 해보자라는 연구도 있었다.
연구도 있었다.

왜하면 아키텍처의 맨날 싸움이 있거든요.
센트럴 라이드 선호 진영 진영이 있고 디센트럴라이즈드 피투피를 사랑하는 진영이 있고 다 있어요.
계속 아직까지도 계속 논란이 돼요. 이거는 정답이 없어요.
다 특징들이 다 다르기 때문에 적용을 어떻게 하느냐에 따라서 이거를 central 라이스 하게 만들 거야 아니면 d centrl이 서버 없이 dicentral 라이스 하게 만들 거야는 다

연구가 되고 있다. 여기도 마찬가지라는 거죠.
에트리벳 기반 네이밍도 디센트럴라이스하게 한번 해보자.
특정 서버가 있는 게 아니고 우리가 옛날에 코드 시스템 맨날 코드 시스템 얘기했었듯이 마찬가지로 그런 속성과 속성에 대한 정보를 여러 노드들이 분산시켜서 가지고 있대 갖고 있대

특정 서버가 있는 게 아니고 서버가 있는 게 아니고 이것도 p2p 형태로 리퀘스트를 룩업 할 수 있게 한번 시스템을 구축을 해보자.
여기서도 이제 dht 기법을 사용을 하겠다라는 거예요.
디스트리뷰티드 해시 테이블 기법을 써서 내가 관리하고자 하는 어떤 속성 어떤 관리하고자 하는 ntt는 여러 노드들이 분산시켜서 관리를 하는데 그럼 이 ntt라고 하는 거를 어떤 놈이 어떤 속성을 갖는 ntt를 관리를 할 거다라는 룰이 일단 있어야 될 거예요.
얘도

얘도 잘 찾으려면 나중에 레졸루션을 잘하려면 코드 시스템에서처럼 뭔가 해시 값을 가지고 이 해시 값보다 크거다.
크거나 같은 놈 중에 제일 작은 노드가 관리하도록 하자.
이렇게 코드 시스템에서 룰을 마련했듯이 여기서도 뭔가 속성이 있으면 이 속성을 갖는 ntt는 어떤 노드가 관리를 할 거야.
이런 룰을 하나 정해가지고 dht로 나눠서 해보자 라고 이제 막 고민을 했던 거죠.
이걸 어떻게 할 거냐

그래서 그걸 하기 전에 얘도 이제 결국에는 해시 값을 쓸 거예요.
이거를 사용을 하기 위해서 어떤 찾고자 하는 속성이 있다면 그 속성에 해당하는 해시값 만들어서 그다음에는 이 해시값을 담당하는 놈을 찾아가는 거는 chord시스템을 써도 되고 다른 정책을 쓰면 되는 거니까요.
해시 값이랑 매핑을 시키는 작업이 일단 필요하다.
내가 관리하고자 하는 속성과 그 속성에 해당하는 해시 값.
이걸 어떻게 할 거냐

이제 avt라고 하는 형태로 구성을 하겠다라는 거예요.
av 트라는 형태로. av 트는 뭐냐 하면 이게 에트리뷰 밸류 트리.
어떤 속성과 값이 있으면 그거를

내가 찾고자 하는 mtt를 속성과 값으로 표현을 해놓으면 그거를 일단 트리 형태로 바꿔서 각 트리의 애지 별로 has 값을 설정을 하겠다는 거예요.

avt이라고 하는 걸 어떻게 만드는 거냐 하면 다음 슬라이드를 보면 알 수 있어요.
여기 왼쪽에 있는 게 속성과 값을 그냥 하이라키카하게 기술을 해놓은 거고 오른쪽이 이 왼쪽에 있는 내용을 avt로 바꿔놓은 거예요.
바꿔놓은 거다.

왼쪽에 디스크립션을 보면 여기 이렇게 인덴테이션에 따라서 인덴테이션에 하나 들어갈수록 하부 속성이 되는 거예요.
이것도 속성이라고 하는 거를 계층적으로 일단 구성을 한다라고 보는 거죠.
트리에 루트부터 칠드런으로

그래서 속성이 뭐가 있냐 하면 타입 타입이라는 놈이 있고 장르라고 하는 속성이 있더라.
타입은 뭐냐 하면 책이야. 내가 찾고자 찾고자 하는 엔티티는 책의 타입을 갖고 있는 놈이야.
책이라는 타입이고 그다음에 장르가 또 있다라는 거죠.
장르는 판타지야. 판타지는 판타지라는 속성을 갖는 책을 찾겠다.

근데 그다음에 또 이제 또 다른 속성이 있는 거죠.
그럼 책인 경우에 책인 경우에는 또 어떤 속성이 있냐 하면 그럼 저자가 뭐냐 저자 저자는 톨킨이고 톨킨이다.
책의 제목은 뭐냐 제목은 이거 뭐 돼요 여러분들이 잘 아는 옛날부터 이게 책이 유명한 책이니까 옛날부터 나온 책이죠.
반지의 제왕 반지의 제왕이에요.

rd 더 링스를 줄여서 그냥 ll tr이라고 해 놓은 거죠.
교재에 그렇게 돼 있네요. 톨킨 책 중에 반지의 제왕 책을 내가 찾고 싶어.
반지의 제왕 책 리소스를 관리하고 있는 노드가 누구야를 찾고 싶은 거죠.
결국에는 그 노드를 찾으면 걔한테 반지의 제왕 책에 대한 내용을 물어볼 수 있을 테니까 일단

이런 속성을 갖는 이 리소스를 누가 관리하고 있는 어떤 로드가 관리하느냐를 찾고 싶다.
그러면 요 속성을 가지고 일단 이거를 그대로 트리 형태로 치안을 해보자.
그래서 이 루트부터 루트 노드는 사실 아무 의미 없고요.
루트부터 속성 에트리뷰트에 해당하는 걸 이렇게 엣지로

구분을 지어놓은 거예요. 엣지로 엣지가 에트리뷰트 이름이에요.
타입이라는 속성이 있고 장르라는 속성이 있고요.
장르라는 그다음에 이 밑에 있는 노드의 값이 이게 해당 에트리뷰트의 값을 노드로 이제 표현을 해놓은 거다.
값을 노드로 매핑을 시켜놓은 거예요.
타입이라고 하는 엣지를 쫙 쫓아갔더니 책이다.
값이 타입은 책이다.

책 밑에 또 속성이 엣지로 이제 또 구분이 되는 거죠.
저자는 뭐고 타이틀은 뭐다 저자의 노드를 봤더니 톨킨 이게 값인 거죠.
노드는 값이고 에지를 에트리뷰트로 표현을 한 거예요.
그러면 이런 식으로 내가 찾고자 하는 ntt의 속성을 딱 기술을 하면 이 속성에 해당하는 avt가 이렇게 마련이 된다라는 거고요.

그러면 이렇게 avt가 나오면 이 트리에서 해시 값을 속성을 관리하는 관리할 노드에 해시 값을 구하자.
dht 어떤 특정 해시 함수를 쓰겠죠 해시 값을 어떻게 쓸 거냐 에트리뷰2와 그 값 별로 각각 따로 해시 값을 만들자.
그래서 타입과 북에 해당하는 해시 값

장르와 판타지에 해당하는 해시값 타입이고 북이고 저자가 톨킨인 요 패스를 따라가는 해시 값 그러니까 av 트를 보고요.
요 엣지를 다 쫓아내려가면서 각각으로 해시 값을 다 마련을 하는 거예요.
그게 어떻게 마련이 되냐 하면 이런 식으로 해시가 6개가 만들어진다.

타입과 북에 해당하는 해시 값 타입과 북과 어서 이렇게 꼭 값으로 떨어지고 에트리뷰 이름만으로 또 떨어지는 놈이 될 수도 있어요.

이거는 이제 뭐예요? 타입이 북이고 모든 저자에 대한 책 이런 내용이 되겠죠 이렇게 이렇게 만약에 쿼리를 날린다면요

요렇게 쿼리를 날릴 수도 있는 거죠.
여기에 해당하는 해시 값도 또 따로 마련을 한다.
이거는 뭐냐 하면 책인데 저자가 톨킨인 모든 책이 되겠죠 그러면 이렇게 쿼리를 날릴 수 있다라고 하는 거.
그래서 여기 avt가 마련이 되면 avt의 각 패스 별로 여기서 여기까지 여기서 여기까지 또 여기서 여기까지 또 여기서 여기까지

여기서 여기 노드 끝까지 여기서 노드 끝까지 6개가 나온다고 치고 그 6개의 해시 값을 마련해서 그러면 그 6개의 해시 값을 담당할 노드를 정하면 된다는 거죠.
담당할 노드를 정해라. 이게 h1부터 h6까지.
그래서 요 각각의 해시 값을 담당하는 노드는

여기 과로 안에 있는 과로 안의 속성에 해당하는 엔티티를 담당하는 놈이야라고 우루를 정한다는 말이죠.
우루를 정하자. h6번  hash값을 담당하는 nod는 nod는 이 성을 이 속성에 해당하는 ntt의 정보를 알고 있는 n 판타지에 해당하는 모든 정보를 알고 있어야 되네.
얘는 그러니까 얘는 범위가 너무 크죠.
그쵸? 이 노드는 범위가 너무 크고 이제 예를 들면 이런 범위를 갖고 있는 관리를 하는 h3 해시 값을 관리하는 노드는 좀

Specific한 소스 정보를 관리하는 노드가 되는 거예요.
포함 관계가 있기는 한데 그래서 이거를 활용을 하면요 이런 거를 찾아줄 수 있다라는 거예요.
톨킨이 쓴 모든 책을 톨킨이 쓴 모든 책의 정보를 내가 알고 싶다.
그 정보를 가지고 있는 리소스 노드의 정보를 알고 싶다.

그러면 톨킨이 쓴 모든 책 그러면 해시 값을 아까 avt로 구성을 하면 아까 이 트리에서 톨킨이 쓴 모든 책을 찾고 싶으면 일단 요게 되는 거죠.
사실은 요거

요 해시 값 avt를 만든 다음에 여기에 해당하는 해시 값을 구하면 될 거예요.
해시 값을 구해서 그 해시 값을 관리하는 노드를 찾으면 돼요.
즉 h3 이게 사실은 가장 spassfi한 쿼이죠 그렇죠? type은 책인데 assor는 톨킨이 톨킨이 쓴 모든 책 에 대한 정보를 관리하는 노드는 이 h3이라고 하는 해시 값을 관리하는 노드일 거거든요.

물론 얘로 뿌려봐도 되고 얘도 뿌려봐도 될 거예요.
h1이나 h2도 다 톨킨뿐만이 아니라 얘네들은 더 많은 정보를 가지고 있는 노드이긴 할 텐데 스페이스 p 한 게 좋겠죠 그래서 h1h2h3 해시 중에 한 놈을 골라가지고 한 해시 값을 골라가지고 이 해시를 담당하는 노드가 누구야?

p2p 상에서 찾으면 거기에 이제 chord 시스템이 적용이 될 수도 있을 거예요.
찾으면 그 노드한테 이제 물어보면 되죠 어? 톨킨이 쓴 책에 대한 정보 좀 알려줘.
그러면 걔가 알고 있으니까 값을 줄 거예요.
이런 식으로 decentrallized 하게 이렇게 표현할 수 있겠다.
타입은 책이고 asson는 톨킨이고 타이틀은

별이네 별. 이게 바로 뭐예요? 톨킨이 쓴 모든 책에 대한 거를 속성으로 기술을 한 거죠.
그리고 그거를 avt로 치환을 하면 오른쪽 그림처럼 된다라는 거죠.
그럼 여기서 패스를 하나 구해가지고 타입 북 어서t킨n에 해당하는 해시 값을 구할 수 있다.
그럼 그 해시 값을 담당하는 노드를 찾으면 그 노드한테 그리고 물어보면 된다라는 거죠.
저기 톨킨의 모든 책에 대한 정보를 좀 줘.
