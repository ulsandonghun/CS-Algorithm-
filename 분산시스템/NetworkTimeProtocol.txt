지난 시간에 ntp를 써서 내 컴퓨터가 더 시간이 정확한 컴퓨터에게 시간 정보를 물어본 다음에 내 컴퓨터의 시간이 그 상대방 컴퓨터의 시간과 얼마나 차이가 나는지에 대한 방법을 살펴봤었죠.
그래서 지난 시간에 봤던
이 그래프를 통해서 단순히 상대방 컴퓨터의 시간 값에서 내 컴퓨터의 시간 값을 뺀다고 되는 게 아니라 여기서 중요한 것은 딜레이 값 내가 시간 값을 물어보는 그 리퀘스트 메시지가 갈 때까지 걸리는 시간
그다음에 이 상대방 컴퓨터가 나에게 응답해줄 때 이 응답 메시지가 날아올 때까지 걸리는 이 시간 딜레이 정보를 고려해서 나의 시간 값과 상대방 시간값과의 차이를 계산하는 방법에 대해서 살펴봤었죠.

그래서 무조건 서로 시간이 동기화되지 않은 컴퓨터 두 개의 컴퓨터의 시간 값을 서로 뺀다든지 하는 것은 의미가 없고 그래서 어떤 아이디어를 썼었냐 하면 나의 내 컴퓨터의 시간 값 총 처음에 여기 t1이라고 하는 내가 시간을 물어보는 물어보기 시작한 시간에서부터


상대 b라는 컴퓨터로부터 응답 메시지를 받을 때까지 걸리는 이 총 시간에서 이 시은 계산할 수 있다고 그랬었죠 t 4에서 t1를 빼면 되니깐요.
t 4에서 t 1을 빼는 거는 의미가 있는 것이 이 t4와 t1은 모두 a라는 컴퓨터의 시간 값이죠 같은
시간 정보는 서로 빼도 괜찮다.
그래서 이 전체 길이에서 뭘 뺐냐 하면 이 사이 값을 뺐었죠 이 사이 값은 뭐냐 하면 비 컴퓨터가 a로부터 요청 메시지를 받아서 받은 시간이 t2고 그다음에 나의 시간 정보를 구한 다음에 응답 메시지를 만들어서 보낼 때까지 걸리는 시간 그게 t 3이었죠


그래서 t2에서 t 3까지 걸린 시간도 t3에서 t2를 뺄 수 있었죠 빼면 이 길이가 나오죠 이것도 t2와 t3은 b 컴퓨터의 시간 값이기 때문에 같은 시간 정보이기 때문에 뺄 수 있다.
그래서 전체 길이에서 요 b가 처리하는 시간을 빼면 어떤 시간 정보가 나왔었냐 하면 여기

두 개 요청 메시지가 간 딜레이 값 더하기 응답 메시지가 도착할 때까지 걸린 딜레이 값에 합한 길이가 나오게 된다.
그 값은 구할 수 있다라는 거죠. 이 네 개의 시간 정보를 이용을 해서 그렇게 구한 다음에 이제 사전 정보 가정이 뭐가 있었냐 하면 이 두 개의 딜레이는 서로 유사하다 거의 같은 길이다라는 가정 하에 우리가 계산해서 구한 이 두 딜레이의 합에서 이를 나눈 값

이를 나누면 이제 둘 중에 하나의 값이 나오겠다라는 거죠.
2를 나눈 값을 구해서 그 딜레이 그래서 여기 하나의 딜레이를 구했던 것이고 그러면 나의 시간 다시 더 앞 슬라이드로 잠깐 돌아가서 이렇게 최종적으로 구하려고 했었던 것은 이 세타 값을 구하려고 했던 것이고요.
이 세타 값은 뭐냐 하면 이 수식 마지막 수식에 의미했던 바는

내 시간 값과 이게 a의 시간이었죠 t4라고 하는 이 시간과 그다음에 b 컴퓨터의 그 해당 시간은 어떻게 구했냐 하면 t 3에서 딜레이 값을 더한 값이었다라는 거죠.
그래서 다시 뒤s라이드로 보면 t 3에서 이 delay 값을 더한 값 그렇죠? 이 지점

표시를 한다면 t4 대비 지금 b 컴퓨터 내가 시간을 물어본 b 컴퓨터에서는 내가 t4일 때에 b 컴퓨터에서의 시간은 t 3에다가 이 delay 값을 더한 값이 된다라는 거죠.
그 더한 값 tst 3 더하기 delay에서 나의 시간을 뺀 값 차이를 얘기하는 거죠.
그 차이 값을 seta라고 하자. 이 세타를 구하고 싶었던 거거든요.

그래서 지난 시간에 set 값을 구했고 시간 차이를 구했어요.
그러면 그 시간 차이를 봤을 때 그 시간 차이에 따라서 나의 시간 정보를 상대방 시간에 맞춰야 되는 거였잖아요.
시간 동기화를 얘기를 하고 있었으니까요.

그렇게 시간을 동기화를 해서 맞출 때 만약에 내 시간이 세터 값이 0보다 작다는 얘기는 아까 수식에서 뒤에 값이 더 크다라는 거죠.
즉 나의 시간이 더 크다라는 거죠. 즉 나의 시간이 더 빠르다 나의 시간이 더 빠른 경우에는 상대방 컴퓨터의 시간에 맞추기 위해서는 어떡하죠? 나의 시간 값을 뒤로 되돌리는 방법이 있겠는데 지난 시간에 하다 말았던 얘기가 그거는 좀 이상하다라는 거였죠

만약에 4시간이 더 느리다면 느리다면 상대방 시간에 맞추기 위해서 그 차이만큼 값을 더하는 것은 어쨌든 이 시간 값이라는 것은 계속 증가하기 때문에 값이 증가하는

라는 것은 그나마 좀

괜찮은데 내 시간이 더 빠르기 때문에 시간 값을 뺀다 그러면 과거로 돌아가는 값이 돼버리기 때문에 그렇게 이 구해진 세타 값, 시간 차이값만큼 나의 현재 시간에다가 값을 이 세타 값을 그냥 더하거나

그냥 빼거나 하는 것은 갑작스럽게 시간이 변화한다는 측면에서는 둘 다 문제가 될 수 있다는 거예요.
더더군다나 내 시간이 더 빠르기 때문에 세터 값을 내 시간에서 빼게 되면 급격히 시간 값이 변화할 뿐더러 더군다나 시간값이 과거로 돌아가버리는 문제가 생긴다.

그래서 시간이라고 하는 것은 항상 증가해야 되기 때문에 그 조건을 유지하면서 시간 값을 조절하기 위해서는 무조건 세터 값을 그냥 더하거나 빼는 방법이 아니라 다른 방법을 써야겠다라는 거죠.
그게 이제 여기 마지막 분릿에 나와 있는 설명이 되는 거고 이 아이디어는 뭐냐 하면 그래서 시간이 가는 속도를 그냥 시간 값을 더하거나 빼는 게 아니라

시간이 가는 속도를 늦추거나 더 빠르게 해서 시간의 변화량을 조절을 하겠다는 얘기입니다.
그래서 내가 시간 값이 더 빠르다라고 한다면 시간 값을 늦추는 거죠.
시간의 변화량을 늦추는 방법 만약에 내 시계가 지금 현재 시간 값이 더 늦다라고 하면

상대방 시간에 맞추기 위해서 나의 시간의 변화량을 더 높이는 거죠.
속도를 더 증가시켜서 더 빨리 변할 수 있게끔 이렇게 시간에 변화량을 조절하는 방법을 써서 급격하게 시간 값을 변경시키는 게 아니라 gr주얼리하게 점차적으로 시간 값이 동기화가 되는 방법을 쓰는 게 맞겠다라는 것이고 그걸 하기 위해서 예를 들면 지금 어떤 시스템에서의 시간이 1초마다



100번의 인터럽트가 발생을 하는 시스템이다라고 이제 가정을 하는 거예요.
어떻게 그레주얼리하게 시간의 변화량을 조절을 할 것인가에 대한 이야기를 하는 겁니다.
그래서 1초라는 시간이 있을 때 이 1초라는 시간 안에 몇 번의 introt가 발생 할 거냐 하면 100번의 nrt가 발생을 하더라 그런 시스템이 있다고 가정을 했을 때 그 얘기는 다시 얘기하면

한 번에 인터럽트가 발생할 때 시간이 얼마라는 얘기냐 하면 10밀리세컨드가 지나간 거라 거죠.
인트로트가 한 번 발생할 때마다 10밀리세컨드가 지나가는 것이다라고 계산을 하면 그러면 이제 10번 introt가 발생을 할 때마다 10ml sec컨드씩 더 한다는 거죠.
그러면


100번의 introt가 발생하고 난 다음에는 1천ml 세컨드가 지나간 거다라고 체크를 할 거기 때문에 그게 이제 1초가 되는 거였는데 그러한 시스템에서 내가 이 set 값을 구해서 속도가 빠르기 때문에 상대방 컴퓨터 비해서 그래서 시간을 늦춰야겠다라고 한다면 그래서 속도를 천천히 가게 하겠다 라고 한다면 이제 아이디어는 매 intropt마다 10ml secund씩 증가를 시키는 게 아니라

그걸 그 값을 작은 값을 더 하겠다라는 거죠.
9ml세컨드만 더한다면 10ml 세컨드 갈 거를 9ml 세컨드만 시간 값을 더하게 되면 시간 값이 덜 더해지는 거죠.
그러면 속도가 늦춰지는 효과를 볼 수 있다.
1초까지 가기 위해서 introt가 이제 더 필요하게 되겠죠.
반대로

내가 시간이 늦기 때문에 속도를 좀 시간 값을 좀 더 빨리 증가를 시켜야겠다라고 한다면 매 introt마다 원래 10ml 세컨드씩 값을 증가했던 것을 10이 아니라 더 많은 값을 예를 들면 11mlsecond라든지 그렇게 더 많은 값을 증가를 하게 되면 introt 개수가 100이 안 될 때 이미 1초가 돼버리겠죠 1초가 지나간 걸로

속도를 더 빠르게 변경시킬 수가 있겠죠.

단순히 이 오프셋 값을 가지고 더 하는 건 그나마 좀 나은데 뺄 경우에는 문제가 좀 커진다.
시간이 과거로 돌아가게 식으로 보정을 하면 안 된다는 얘기죠.
이 부분도 고려를 좀 해야 할 것이다.
그래서 이제 지난 시간에 봤던 시간을 동기화하는 그 아이디어를 기반으로

mtp라고 하는 프로토콜이 어떻게 돌아가는지를 다시 한 번 살펴보면 network 타임 프로토콜의 약자죠 ntp가.
이 프로토콜의 아이디어는 내가 나보다 정확한 시간을 알고 있는 서버에게 물어본다라는 거죠.
지금 몇 시예요라는 걸 물어봐서 응답이 오면 그 시간에 맞춰서 나의 시간을 조절하겠다.

이게 이제 ntp의 기본 개념인데 여기서 이제 프라블럼이라고 나와 있는 건 뭐냐 하면 지금 분산 시스템에서는 컴퓨터들이 여러 개가 있잖아요.
그중에 아무런 룰이 없으면 내가 임의의 컴퓨터에게 시간을 물어봐야 될 수가 있을 텐데 그렇게 임의의 컴퓨터한테 물어보면 안 된다라는 거죠.
왜냐하면 내가 임의로 선정한 그 컴퓨터가

내 시간보다 더 부정확한 시간을 가지고 있는 놈이면 안 되잖아요 그렇죠? 내가 물어본다라는 거는 적어도 나보다 정확한 시간을 알고 있는 놈한테 내가 현재 시간을 물어봐야 되는 거지 반대가 되면 안 된다.
그래서 그 룰을 좀 만들어야겠다라고 한 얘기고요.
그 룰이 없으면 안 된다. 그러면 나보다 부정확한 놈한테 시간을 물어봐서 보정을 해버리면 더 시간이 어그러져 버릴 테니까 그런 문제를 해결하기 위해서는 ntp에서 작동하는 서버가 하나가 아니고 여러 개가 있을 텐데 그 여러 개의 서버를

단계로 나누자라는 거예요. 단계로 나눠서 단계라고 하는 건 뭐냐 하면 정확도 지금 그 서버에서 도는 시간의 정확도 우리가 표준으로 삼는 시간은 utc라고 그랬죠 utc를 기준으로 했을 때 제일 좋은 놈이 단계가 제일 높은 서버고 utc보다 조금 틀어진 놈은 그 다음 단계의 서버고 이렇게 서버가 가지고 있는 시간의 정확도를 단계로 나누자라는 거예요.
그거를 이제 스트라타(starta)

스트라트 텀(Stratum 1) 이게 숫자가 작을수록 더 정확도가 높은 서버다.
그래서 서버가 저런 단계를 가지고 있는 거예요.
나도 단계를 가지고 있고 내가 가지고 있는 그 시간의 값이라고 하는 게 몇 단계짜리 시간이냐 이 정보는 알고 있는 다음에 이제 하자는 거죠.

그러면 이제 a라는 컴퓨터가 b라는 컴퓨터에 컨택을 했을 때 시간을 물어볼 거냐 말 거냐를 이 단계 값을 보고 결정을 하자는 거죠.
내가 컨택한 그 컴퓨터의 단계가 더 높은 단계인 컴퓨터야.
내가 시간을 물어볼 거고 내가 컨택을 했는데 그 컴퓨터가 나보다 단계가 낮은 놈이면 물어볼 필요가 없다라는 거죠.
나보다 더 시간이 부정확한 놈이기 때문에 그런 사항을 적용을 하자.
이제 ntp 기본 개념을 알았고요.
Clock synchronization clock synchronization algorithms: the Berkeley algorithm
다른 시간을 동기화하는 또 다른 알고리즘이 있어요.
이건 이제 버클리 알고리즘이라고 이름이 붙여져 있다.
얘도 유사해요. 얘도 서로 컴퓨터들 간의 시간을 똑같이 맞추겠다라고 하는 아이디어를 가지고 있는 놈인데 여기 어퍼 어프로치라고 돼 있죠 ntp랑 반대의 개념을 가지고 있다.

그 얘기는 뭐냐 하면 ntp는 클라이언트가 서버에게 물어봤죠 클라이언트가 서버에게 지금 시간이 몇 시에요 그래서 받으면 그 시간에 맞춰서 내가 시간을 보정을 한 거였어요.
근데 이 버클리 알고리즘의 기본 개념은 뭐냐 하면 시간이 정확한 놈이 정확한 시간을 알고 있는 놈이 거꾸로 클라이언트한테 물어봐요.
지금 너네들 시간이 몇 시야?

라는 걸 거꾸로 물어와서 그 정보들을 다 받아요.
클라이언트의 시간 정보를 다 받아서 서버가 결정을 해요.
클라이언트가 어떻게 시간을 보정해야 할 건지를 서버가 계산해서 거꾸로 알려줘요.
클라이언트들한테 너는 요만큼 보정하고 너는 요만큼 보정하고 너는 요만큼 보정해

라고 서버가 거꾸로 클라이언트에게 어떻게 보정해야 될 건가를 알려준다.
그 전에 시간도 누가 물어보냐 하면 서버가 클라이언트한테 물어보는 거예요.
지금 너네들의 시간이 얼마야? 또는 내 시간을 알려줄 테니 너네 시간이 지금 얼마나 차이가 나 그 차이가 나는 정보를 나한테 알려줘.
어쨌든 서버가 클라이언트한테 물어본다.
ntp는 클라이언트가 서버한테 물어보는 거였어요.
그 개념에서 이제 반대라는 얘기예요.
어프로치가.

그러면 서버는 클라이언트한테 거꾸로 시간 값을 물어본 다음에 어떻게 이거를 동기화를 하는 거냐 이거는 예제를 보면서 하는 게 이제 좀 더 직관적이거든요.
뒤에 슬라이드에 나와 있는 예제 그림을 한번 보죠.
지금 세대가 있는 거예요. 컴퓨터 세대가 서로 시간을 동기화를 하고 싶다.

지금 현재 시간을 보니까 지금 이 놈이 서버의 역할을 할 거예요.
위에 있는 컴퓨터가 내가 서버야 라고 일단 가정을 하고 있는 상황이고 그 서버는 지금 3이에요.
3이. 이 놈은 2시 50분이네. 2시 50분이고 요 놈의 시간은 3시 25분.
이렇게 서로 다 다르죠 시간이 서로 다 다른데

이 세 개의 컴퓨터의 시간을 어떻게 동기할 거냐를 위해서 먼저 이 서버의 역할을 하는 놈이 나머지 두 놈한테 물어보는 거죠.
반대죠 거꾸로 물어봐서 너네 지금 시간이 얼마야? 라고 물어볼 수도 있는데 지금 요 예제에서는 뭘 물어봤냐 하면 이런 식으로 물어봐요.
서버가 클라이언트한테 지금 내 시간이 3이니까

너네 시간이 얼마나 내 시간 대비 얼마나 차이가 나는지를 나한테 알려줘라고 물어보는 거예요.
지금 클라이언트한테 물어. 결국엔 같은 얘기예요.
얘네 시간 값을 가지고 와서 여기서 차이를 계산하든지 너네가 직접 차이를 계산해서 나한테 알려줘라든지 결국에는 서버가 알고 싶은 거는 클라이언트가 내 시간과 지금 얼마나 차이가 나는지를 알고 싶은 거예요.
서버가. 그래서 클라이언트한테 일단 물어본다.
지금 셋이라는 거를 지금 알려주죠.

셋이라는 거 내 시간 정보를 보내줄 테니 너네가 거꾸로 나한테 알려줘.
지금 얼마나 시간 차이가 나는지를. 그래서 요 놈인 경우에는 어때요? 나는 셋인데 얘는 2시 50분이니까 얘는 나보다 10분이 느린 거잖아요.
그렇죠? 10분이 더 느린 놈이다. 그래서 이제 마이너스 10이라는 걸 얘가 알려주는 거예요.
내가

너보다 10분 느려라는 의미죠. 얘는 반대로 3시 25분이니까 3시보다 25분이 더 빠른 거죠.
나는 너보다 25분이 더 빠른 놈이야 라는 걸 알려준다.
나한테도 물어본다. 나 자신한테도 물어본다.
이거야 0이죠 내 시계는 빵이니까 똑같으니까 그렇죠? 나한테도 물어보고 어쨌든 다 물어봐서 이렇게 다 수집을 해요.

0 10 플러스 25 이렇게 다 수집을 한 다음에 그다음에 보세요.
그다음에 뭘 하냐 하면요. 얘는 이 차이 나는 정보들에 그냥 평균을 구해버려요.
평균 평균값 그 평균값으로 다 그냥 수정해버리자라고 정해요.
평균이 마이너스10하고 25 하면

15잖아요. 15를 3으로 나눈다는 얘기죠.
참여한 컴퓨터의 개수대로 그냥 나눠가지고 평균을 내버리면 5 5 플러스 5가 되죠.
그 얘기는 뭐냐 하면 서버 입장에서는 나는 내 시간을 3시가 아니고 지금 3시 5분으로 바꾸겠다라는 거예요.
3시 5분 모든 세대의 컴퓨터의 시간을 3시 5분으로 다 맞추자라고 정한 거예요.
결국에

그래서 그 사실을 다른 클라이언트들한테도 알려줘요.
얘는 2시 50분에서 3시 5분으로 바꿔야 된다는 얘기죠.
그러니까 15를 넌 더 해. 얘는 거꾸로 3시 25분에서 3시 5분으로 바뀌어야 되니까 너는 마이너스 20 해.
이런 식으로. 이거 조금 이상하지 않아요? 어쨌든 얘네들은 이 세 개의 컴퓨터

시간을 동일하게 맞추는 알고리즘이기는 해요.
그렇죠? 그렇긴 한데 머릿속에 조금 이상하다고 생각이 되는 건 뭐냐 하면 저렇게 저런 식으로 하면 utc랑 또 틀려질 텐데 지금 전 세계에서 돌아가고 있는 표준 시인 utc가 있을 텐데 걔네는 무시하고 그냥 얘네들끼리만 맞추겠다는 얘기예요.
얘네들끼리만.

유티씨는 무시하고 그래서 버클리 알고리즘의 아이디어는 그거예요.
그거. 우리 ntp 좀 전에 봤었던 ntp는 utc 정확한 시간을 알고 있는 놈한테 클라이언트가 물어봐서 거기에 맞추는 거였죠 클라이언트가.
그래서

utc를 따라서 맞출 수가 있다. ntp를 사용을 하면 근데 이 버클리 알고리즘은 utc는 무시하자 유티씨는 무시하고 나는 유티씨는 모르겠고 그냥 우리들끼리만 일단 맞추자라는 거예요.
우리들끼리만 시간 정보를 맞추자. 그 차이가 가장 크다.
ntp랑 비교를 하면 돼요.

그래서 클라이언트한테 물어본 다음에 시간 정보를 그래서 시간 차이를 물어봐서 클라이언트가 알려준 그 대답에 따라서 기반을 해서 서버가 에버리지 타임을 계산을 한다라는 거죠.
그 얘기가 그 얘기예요. 시간 차의 정보 값들을 다 모아가지고 그 차이의 평균을 그냥 구해버린다.
거기에 맞춰서 다 보정을 하겠다라는 거죠.
그래서 내 시간을 일단 바꾸고

그 내시간에 다른 컴퓨터들이 다 맞추도록 거꾸로 알려준다라는 거죠.
너는 얼마큼 수정해 너는 얼마큼 보정해라는 걸 거꾸로 클라이언트들한테 알려준다.
그래서 이 버클리 알고리즘 방법은 어디에 적합하냐 하면 어떤 컴퓨터도 요 리시버를 가지고 있지 않은 놈 요 리시버(WWV)(정확한 UTC의 시간정보에 대한 전파를 받을수 있는 리시버)를 가지고 있는 놈은 어떤 놈이에요? utc를 알고 있는 놈이라는 얘기죠.
요 리시버라는 얘기는 utc 시간 값을 받을 수 있는 놈이거든요.
요 리시버가

utc를 모르더라도 모르더라도 그냥 자기네들끼리만 시간을 동기화하고 싶다면 버클리 알고리즘을 사용을 하면 된다.
아이디어는 간단하잖아요. 그쵸?

그러니까 이제 시간을 동기화한다라는 게 이제 처음에는 처음에는 어떤 생각이었냐면 시간을 컴퓨터들 간의 시간을 동기화를 하려면 일단 이 방에 있는 모든 컴퓨터들의 시간을 유티씨에 다 맞춰야겠어라고 처음에 이제 생각을 했던 거예요.
ntp 프로토콜이 만들어진 게 일단 세계 표준시에 무조건 맞추자.

그렇게 해서 막 애를 썼는데 그래서 utc 정보도 어떻게든 가지고 오고 막 딜레이도 고려를 하고 그렇게 했었는데 좀 하다 보니까 그렇게까지 할 필요가 있는가라는 거죠.
지금 이 방에 있는 컴퓨터들끼리만 지금 뭔가를 할 건데 그럴 거면 지금 분산 시스템에서는 뭔가 이벤트의 발생 순서 이런 게 사실은 좀 중요하거든요.
그것만 맞추면 되는 게 아닌가 그러려면

utc 시간이 지금 어떻건 상관없이 여기 안에 있는 참여하는 컴퓨터들끼리만 시간을 맞으면 되지 않겠느냐 그래서 약간 뭐죠? 요구 사항이 조금 완화된 거예요.
시간 동기화를 하는 데 필요한 utc에 굳이 마칠 필요는 없겠다.
그냥 우리끼리만 맞추자 시간을. 그게 이제 버클리 알고리즘인 거고 그다음에 이제 한 단계 더 나간 게 이거예요.

Logical clocks
그 시간 동기화의 조건을 제약사항을 좀 더 완화시킨 게 지금 오늘 얘기할 로지컬 클락이다.
로지컬 클락 로시컬 클라이니까 뭐겠어요 이게 논리적인 시계 논리 시계 그러니까 진짜 시계가 아니라는 거죠.
우리가 지금 앞에서 봤던 mtp나 버클리 알고리즘으로 동기화를 시켰던 건 진짜 시계죠.
똑딱똑딱 월 클락

월 클락 타임을 동기화를 시켰던 건데요.
지금 로지컬 클럽은 그런 월 클락 타임이 아니에요.
똑딱똑딱 1초 1초씩 늘어나는 그 시계가 아니고 여기서의 이제 클락은 따로 따로 정의했어요.
따로 정의한 시간이 있어요. 로지컬 클락이라고 하는 논리 시계를 따로 정의를 해서 이 컴퓨터들끼리 반끼리 일단 우리끼리만 맞추면 된다라는 전제 하에서 우리끼리 시계를 따로 만들자라는 거예요.
이젠 또

월 클락 타임을 쓰지 말고 그 시계는 월 클록 타임과 다르다.
가장 큰 차이점은 뭐냐 하면 이 시계는 시계이기 때문에 이제 시간 값이 있어요.
얘도 시간 값이 있어서 시간이라는 거는 계속 증가해야 되잖아요.
그쵸시간 값이라고 하는 게 근데 월 클락 타임처럼 똑딱똑딱 월 클락은 어때요?

옛날 우스개로 막 그런 군대 뭐지? 하여튼 뭔 일이 일어나도 군대 시간은 돌아간다.
그러니 시간은 멈추지 않는다 이러잖아요.
그렇죠? 이 월 클록ck이라고 하는 거는 우리가 아무 짓도 하고 있지 않아도 어쨌든 시간은 계속 흘러가죠.
그쵸? 계속 흘러가는 시간인데 이 로지컬 클록은 무조건 흘러가는 시계가 아니고 이벤트가 발생해야만 흘러가는 시계예요.
얘는 얘 시계는

어떤 이벤트 컴퓨터에서 얘기하는 어떤 특정 이벤트가 발생할 때만 증가하는 시기예요.
매번 아무 짓도 안 하고 있는데 시간이 똑딱똑딱 흘러갈 필요가 있느냐 그러지 말고 이 로지컬 클럽은 이벤트가 발생할 때만 시간 값을 증가시키는 그런 시계를 사용하자는 거예요.

그리고 이제 또 이거를 사용하는 이유가 뭐냐 로시카 클락이라는 로시카 클락을 사용하는 이유는 앞에서 봤던 시간 동기와 메카니즘을 봤더니
리얼 타임이라는 게 이제 월 클록 타임을 얘기를 하는 거죠.
계속 흘러가는 지금 현재 시간에 맞춰서 컴퓨터를 동기화를 시켰는데 좀 살펴보니까 살펴보니까 매번 돌아가는 저 시간에 모든 컴퓨터들의 시간을 맞출 필요가 과연 있느냐라는 이제 의문이 드는 거예요.
의문이 들어서

좀 살펴봤더니 각 노드들이 컴퓨터들을 얘기를 하는 거죠.
분산돼 있는 컴퓨터들이 서로 협력하는 이 컴퓨터들이

현재 시간이 얼마냐 현재 지금 몇 시야 라는 게 중요한 게 아니고 지금이 몇 시야라는 게 중요한 게 아니고 지금 현재 시간을 알고자 하는 거는 우리가 컴퓨터 분산 시스템의 작동을 봤더니 발생한 이벤트에

순서 관계를 따지기 위해서 현재 시간을 알고 싶었던 거였어요.
결국에는 현재 시간을 알고자 하는 거는 비교를 하기 위해서 그런 거죠.
컴퓨터들의 시간을 다 똑같이 맞춘 다음에 그 얘기는 뭐냐 하면 이 컴퓨터에서 발생한 이벤트와 이 컴퓨터에서 발생한 이벤트가 있는데 둘 중에 처음에 그거였죠 처음 시작이 이 두 이벤트 중에 누가 먼저 발생한 이벤트야 이렇게 순서를 파악해야 될 필요가 있어서 시간에 동기화를 했던 거였거든요.

그렇게 시간 동기화를 하기 위해서 간단한 방법은 두 컴퓨터의 시간만 맞으면 그러면 이제 이 컴퓨터에서 발생한 이벤트를 다른 컴퓨터로 전송할 때 그 메시지 안에 시간 값을 넣으면 된다고 그랬죠 시간 값을 넣으면 다른 컴퓨터가 그 메시지를 받으면 그 메시지 안에 들어있는 시간과

내 컴퓨터의 시간을 비교할 수 있잖아요.
비교를 해서 그러면 어떤 이벤트가 더 먼저 발생한 이벤트야라는 거를 비교할 수 있다.
그래서 시간을 동기화하려고 했던 거는 이벤트가 서로 누가 먼저 발생한 이벤트야라는 거를 그 순서 관계를 파악하기 위한 용도였다는 거죠.
clock sincronazation을 했던 게

앞에서 지난 시간에 예제로 들었던 이 메이크 컴파일러도 마찬가지였다.
메이크도 소스 파일이 수정된 시간과 이게 컴파일 돼서 생성된 오브젝트 파일이 생성된 시간을 비교해서 다시 컴파일을 할 거냐 말 거냐를 얘가 판단을 한다고 그랬죠 어느 시간 값이 더 컴파일 된 시간이 더 나중이면 이건 다시 컴파일을 해야 된다 이렇게 판단한다고 그랬잖아요.

그래서 컴파일 된 이벤트 그다음에 오브젝트 파일이 생성된 이벤트 그 두 개의 이벤트가 있을 텐데 그 두 이벤트의 시간 순서를 파악할 수 있으면 된다라는 거죠.
그래서 이 소스 파일의 이벤트가 더 나중에 발생됐어라는 것만 알면 그러면 다시 컴파일 하면 되는 거거든요.

그래서 이벤트의 순서 관계만 알면 되겠더라.
그냥 우리가 힘들게 컴퓨터들 간의 시간을 똑같이 맞추려고 애를 쓰지 말고 애를 쓰지 말고 그냥 이 분산 시스템의 컴퓨터들 사이에서 발생한 이벤트들의 우리가 관여하는 이벤트들 중에 어떤 이벤트가 먼저 발생한 거다라는 것만

그 컴퓨터들끼리 서로 합의할 수 있으면 서로 다 동일하게 동의할 수 있으면 그걸로 충분하다라는 거죠.
그러니까 월 클락 리얼타임 그냥 쓰지 말고 이게 사실 좀 귀찮거든요.
시간 동기화를 한다는 게 이게 한 번 하고 끝나면 모르겠는데 주기적으로 해야 된다고 그랬죠 매번 이 컴퓨터들의 시간이 제각각 돌아가기 때문에 좀 시간이 지나면 또 차이가 나니까 또 동기화하고 또 가다 보면 또 차이가 벌어지니까 또 동기하고 막 이런 작업을 해야 돼요.
시간 동기화를 하는 것도. 그래서 오버헤드가 드는 거예요.
자주 하면 자주할수록

시간 동기화를 잘 하려면 자주 해야 되는데 자주 하면 오버이드가 커지고 이것도 좀 문제라는 거죠.
시간 동기화를. 그러니까 이런 대안을 생각을 했던 거고 이게 굉장히 램포트라는 지금 이 분산 시스템 세계에서는 유명한 사람이에요.
이분이 굉장히 오래전에 굉장히 오래전에 이 la시카 클락이라는 개념을 처음에 생각을 했다.
그런 아이디어로 이제 나온 거죠.

처음에 utc에 맞춰서 다 동기화를 하려고 하다가 꼭 굳이 뭐 utc에 맞춰야 돼 그냥 우리끼리만 시간 맞추자 라고 하다가 근데 꼭 이 벽시계 이게 시간을 맞출 필요가 있어.
그냥 이벤트의 순서 관계만 우리끼리 서로 합의를 할 수 있게끔만 조작을 한번 하자.
그래서 우리만의 시계를 만들자. 그게 이제 로시카 클락이라는 거예요.

Logical clocks: Lamport’s logical clocks
그래서 로컬 클록이 어떤 식으로 이제 돌아가느냐 로지칼 클록 자체는요 이것도 그냥 하나의 숫자예요.
로지칼 클록. 모든 컴퓨터들은 자기만의 로지컬 클록을 시계를 가지고 있고 그 시계의 시간 값이라고 하는 거는 그냥 숫자예요.
숫자 숫자로 생각하면 돼요. 근데 그 숫자가 이제 시간이니까 시계니까 이 숫자가 증가하는데 증가하는데 리얼타임처럼 똑딱똑딱 이렇게 주기적으로 증가하는 시간이 아니고

언제 이벤트가 발생할 때만 시간 값을 증가시키겠다라는 거예요.
이벤트가 발생할 때만. 그러면 이제 이벤트의 순서 관계를 표현하는 게 중요하거든요.
이벤트의 순서 관계 이 로지칼 클락에서는 그러기 위해서 두 이벤트 간의 관계를 하나 굉장히 직관적인 관계예요.
Happens-before relation이라고

두 이벤트 a라는 이벤트와 b라는 이벤트의 관계를 저런 식으로 정의를 하기 시작했다.(ab)
해픈스 비포니까 뭐예요? 해 발생했다 비포 전에 전에 발생한 두 이벤트 간에 이렇게 화살표로 이렇게 보통 표시를 하는데 이렇게 보면 직관적이잖아요.
a 다음에 b가 발생한 것처럼 보이죠 눈으로 보기에도.
그러니까 이렇게 표현을 한다는 거예요.


해픈스 비포 b라는 거죠. 영어로도 이렇게 만나는 이 화살표가 해픈스 비포로 치환하면 되는 거예요.
a는 b 전에 발생했다. 그래서 이 a와 b 두 이벤트 간에 이렇게 순서 관계를 모든 컴퓨터들이 다 합의할 수 있으면 동의할 수 있으면 저 두 에이라는 이벤트와 b라는 이벤트는 해픈 스피포 릴레이션을 가지고 있다라고 정의를 하자라는 거예요.

여기서의 과정은 모든 컴퓨터들이 다 동일한 순서로 발생했다고 합의를 해야 된다라는 거예요.
나는 a가 먼저 발생했다라고 했는데 딴 놈은 b가 먼저 발생했다라고 판단을 해버리면 안 된다라는 거죠.
모든 컴퓨터들이 동일하게 이 이벤트는 이 이벤트보다 앞서서 발생한 이벤트야 라는 거를 다 동일하게 합의할 수 있으면 haponsfifor relation이 만족이 되는 거예요.

그러면 이러한 케이스가 뭐가 있느냐 모든 컴퓨터들이 논란의 여지 없이 먼저 얘가 먼저 발생한 거야 발생한 이벤트야 라는 거를 확실하게 알 수 있는 이벤트가 있을 수 있고 확실하게 알 수 없는 이벤트가 있을 거거든요.
컴퓨터에서 발생하는 이벤트들은 그러니까 잘 모르겠는 이벤트는 빼고 빼고 그건 과감하게 버리고

순서 관계를 확실하게 알 수 있는 이벤트에 대해서 이벤트에 대해서 해픈스 비포 릴레이션을 일단 정의를 하자라는 거예요.
그 두 가지 케이스가 여기 있어요. 순서 관계를 확실하게 알 수 있는 이벤트의 케이스가 두 가지.
첫 번째는 뭐냐 하면 이벤트와 b 이벤트가 같은 프로세스에서 발생한 이벤트다 라고 한다면



그리고 그 같은 프로세스에서 a가 b보다 먼저 발생한 이벤트라면 이벤트라면 그러면 이건 당연히 당연히 a와 b 사이에는 해픈 스피포 릴레이션이 존재한다.
이건 이제 우리가 아까 얘기했던 하나의 프로세스가 가지고 있는 로지컬 클락이 있을 텐데요 로지컬 클락이 있어요.

이벤트가 발생할 때마다 값을 증가시킬 거예요.
미리 얘기하면 로지카 클럽이 어떻게 증가하냐 하면 이벤트가 발생하면 그냥 시간 값을 증가시키거든요.
a가 발생했을 때 뭔가 로지 클럽 값이 있을 거예요.
그다음에 b가 발생했을 때 로지카 클라 값이 있을 텐데 얘는 지금 같은 프로세스에서 발생한 이벤트이기 때문에 이 이벤트의 순서 관계를 파악하기 위해서는 그냥 이 컴퓨터에 이 프로세스의 로지카 클럽 값을 그냥 비교하면 돼요.
그쵸?

같은 시계를 사용해서 발생한 이벤트이기 때문에 이 둘 사이의 값은 비교를 하면 누가 먼저 발생했는지 알 수 있고 한 프로세스에서 발생한 이벤트니까 이거는 다른 모든 컴퓨터들도 이 a와 b 이벤트에 대해서는 당연히 다 그렇게 생각을 한다는 얘기죠.
로시카 클라 값을 봤더니 같은 컴퓨터에서 발생한 로시카 이벤트의 로시카 클라 값을 봤더니

요 이벤트의 로지카 클라 값이 더 크네 그럼 얘가 나중에 발생한 이벤트네라는 거를 확인할 수 있다라는 거죠.
다른 모든 컴퓨터들도 요 a b의 이벤트와 로지카 클라 값을 보면 이게 비교가 된다라는 거죠.
왜냐하면 같은 컴퓨터에 같은 로시카 클럽 상에서 발생한 이벤트들은 어떤 숫자가 더 크냐 작냐에 따라서 누가 먼저 발생했냐 나중에 발생했냐를 비교할 수 있기 때문에 비교할 수 있기 때문에(그래서 Happens-before relation이 존재함, 순서관계를 확실하게 알 수 있기 때문임.)

그래서 한 컴퓨터에서 발생한 한 프로세서에서 발생한 두 개의 이벤트 서로 순서 관계가 파악이 되면 이거는 다른 모든 컴퓨터들도 다 당연히 동의할 수 있는 happens before 릴레이션을 갖는 이벤트다.

그리고 두 번째는 뭐냐 하면 이거는 이제 메시지를 보내고 받는 이벤트.

여기서의 이벤트는 뭐냐면 이거는 이제 한 컴퓨터에서의 두 이벤트가 아니고 다른 컴퓨터에서 발생한 두 이벤트인데 한 이벤트는 메시지를 보내는 이벤트예요.
메시지를 보내는 이벤트. a라는 이벤트는 메시지가 보내졌다라고 하는 이벤트고 b라는 이벤트는 다른 컴퓨터가 그 메시지를 받았다고 하는 이벤트예요.
받았다고 하는.

그러니까 a라는 이벤트와 b라는 이벤트는 서로 다른 컴퓨터에서 발생한 이벤트이기는 한데 한데 a는 보내진 이벤트고 b는 그 메시지를 받은 이벤트예요.
그러면 누가 봐도 누가 봐도 보낸 다음에 받아야 되는 거잖아요.
그렇죠? 보내기 전에 받을 수는 없잖아요.
이거는 자명한 사실이잖아요. 그렇죠?

그래서 저런 경우에는 같은 메시지에 대해서 보내는 이벤트와 받는 이벤트는 이건 누구도 논란의 여지 없는 해픈 스피커 릴레이션이 존재한다는 거죠.
보낸 다음에 받아야 되니까. 그래서 이때 a와 b 사이에는 해픈스 비퍼 릴레이션이 존재한다.(순서관계가 명확하게 정해지므로, Happens-before relation 존재)
왜? 딜레이 때문에 커뮤니케이션 딜레이 때문에 보낸 다음에 받을 수밖에 없는 거죠.

그래서 저 두 종류의 이벤트에 대해서는 해픈스 비포 릴레이션이 일단 존재한다라고 일단 머릿속에 박아두자.( 같은 컴퓨터 안에서 이벤트가 발생하는 경우, 메시지를 보내고 받는 이벤트)
같은 프로세스 안에서 발생한 이벤트들은 당연히 해픈 스피포 릴레이션이 존재하고 이건 다른 컴퓨터들도 다 다 확인할 수 있는 거고 그리고 보내고 받는 이벤트도

Happens before 릴레이션이 존재하고 이것도 다 모든 컴퓨터들이 당연히 합의할 수 있는 이벤트다.
그렇지 않은 이벤트도 많다라는 거죠.
그렇지 않은 이벤트도 2개의 컴퓨터가 있는데 여기서 뭔가 이벤트가 발생하고 이 컴퓨터에서 뭔가 이벤트가 발생했어요.-->Happens before relation을 가질수 없는 이벤트
근데 저

이벤트가 서로 연관관계가 없는 그냥 인디펜던트한 독립적인 두 개의 이벤트라면 로지카 클락을 가지고는 지카 클락만 가지고는 이 두 독립적인 이벤트는 누가 먼저 발생한 거야를 판단할 수는 없어요.
판단할 수는 없겠죠 비교가 안 되니까. 순서관계가 명확하게 이루어지지 않으므로.
비교가 안 돼요. 얘가 먼저 발생한 건지 얘가 먼저 발생한 건지를 알기는 어렵다.
알 수 없다.

그래서 로지카 클럽으로 모든 이벤트에 대해서 순서 관계를 다 알 수 있는 거냐 로지카 클럽만 가지고는 좀 부족한 거고 그러기 위해서는 또 다른 정보가 필요해요.
모든 발생한 이벤트의 순서 관계를 전부 다 다 동일하게 전부 다 맞추겠어 라고 한다면 그렇게 할 수는 있거든요.
그러려면 추가적인 정보가 더 필요하다.

그거는 이제 좀 더 복잡해지는 얘기니까 그건 나중에 기회가 되면 얘기하도록 하고 그다음에 해픈스 before 릴레이션은 transitive한 릴레이션이다라고 갑자기 논리 시간이 돼버렸는데 트렌지tvt에 대해서 여러분들 들어봤죠? 이게 우리 말로는 뭐지? 트렌지티브하다라는 게

a이면 b고 b이면 c이다. 그러면 a이면 c다.(ab and bc is ac)
이게 만족이 되면 트렌지티비티가 있다라고 얘기를 하거든요. (삼단논법)
여기 나와 있는 것처럼 a면 b고 b이면 c다.
이 두 개가 True라면 그러면 a이면 c다.
이것도 맞는 말이다. 얘도 트루다 라고 하는 게 이제 transitivity거든요.
Happens-before relation은 Transitivity를 만족한다.

a가 b보다 먼저 발생한 이벤트고 b가 c보다 먼저 발생한 이벤트라면 그럼 당연히 a는 c보다 먼저 발생한 이벤트가 되겠죠 이것도 만족한다.
저 트렌지 티비티의 특성을 또 이용을 하면 또 관계가 없었던 것처럼 보이는 두 이벤트 간에도 누가 먼저 발생한 이벤트야 라는 거를 또 파악할 수 있다라는 거죠.
트렌지티비티 특성을 이용을 하면

이거는 이제 순서 관계를 파악할 수 없는 이벤트 로지카 클락만으로 만약에 두 x하고 y라는 이벤트가 서로 다른 프로세스에서 발생을 했는데 둘 사이에는 전혀 연관관계가 없다라는 거예요.
독립적인 이벤트 x와 y다. 그러면 x가 먼저 발생한 이벤트인지 아니면 y가 먼저 발생한 이벤트인지는 알 수가 없고 로시카 클라그만으로는

그러한 두 이벤트 독립적인 이벤트는 컨커런트(Concurrent)한 이벤트다라고 일단 용어를 하자.
컨커런트하다라는 거는 이게 동시적이라는 얘기했죠 동시적 컨커런트 컨커런트하다라는 거는 동시에라는 말이긴 하거든요.
진짜 동시는 아니지만 동시인 것 같은 의미를 가지고 있어요.

엑스하고 y 이거는 그러니까 애매하니까 누가 먼저 발생하는지 모르니까 그냥 거의 거의 동시에 그냥 발생한 이벤트라고 치지.
뭐 그런 의미에서 저런 두 이벤트는 컨커런트 이벤트다 라고 얘기를 해요.
그러면 이제 이런 정보를 가지고 필요한 게 뭐냐 이제

해픈스 비포 릴레이션을 로지컬 클락을 가지고 판단할 수 있으면 파악할 수 있으면 좋겠다라는 거예요.
그래서 로지카 클락이라는 거를 한번 정의를 해보자.
해프스비포 릴레이션이 있는 이벤트에 대해서는

이 로지카 클락의 값을 서로 비교를 하면 누가 먼저 발생한 이벤트다라는 거를 파악할 수 있게 판단할 수 있게 로지카 클락을 한번 디자인을 해보자라는 거예요.
그래서 여기 ca라고 하는 게 뭐냐면 이게 대문자 c가 로시카 클록 값이에요.
로시카 클라 값 뭐에 대해서? 괄호 안에 있는 이 a가 이벤트인 거죠 a라는 이벤트에 해당하는 로지카 클라 값 숫자가 나오겠죠 어떤 시간 값 그 숫자 값을

가지고 모든 분산돼 있는 모든 컴퓨터들이 동일한 순서로 이벤트가 발생했다는 거를 판단할 수 있게끔 로지컬 클록을 디자인을 해보자라는 거예요.
그래서 로지컬 클락을 어떻게 이제 측정을 할 거냐 어떻게 정할 거냐 값을 두 개의 이벤트 이거 아까 첫 번째 조건이었죠 자명한 사실 해픈스 비포 릴레이션이 있는 자명한 사실인 두 이벤트 중에 하나 a와 b라는 두 개의 이벤트는 같은 프로세스에서 발생한

이벤트라면 a가 b보다 먼저 발생한 이벤트인 게 확실하다면 확실하다면 그러면 이 a의 로지카 클라 값과 b의 로지카 클라 값은 이런 조건이 만족돼야 된다(C(a)<C(b))라는 거죠.
숫자라고 그랬죠 숫자. 그래서 로시카 클라 값의 숫자를 비교해서

더 크면 더 큰 rosca 클럽 값을 가지고 있는 이벤트는 나중에 발생한 이벤트다라고 알 수 있게 하자는 거 당연한 얘기죠 숫자 시간은 숫자고 시간이 시간 값이 더 크다라는 거는 더 늦게 발생했다라는 걸로 파악을 하자라는 얘기예요.

만약에 이건 두 번째 해픈스 비포 릴레이션을 갖는 이벤트예였죠 a는 보내는 이벤트였고 b는 다른 컴퓨터가 받는 이벤트였다.
그 메시지를 같은 메시지라는 연관관계가 있죠 여기서 a와 b 두 개의 이벤트는 서로 다른 컴퓨터에서 발생한 이벤트이기는 하나 독립적인 이벤트가 아니고 서로 연관관계가 있는 이벤트예요.
같은 메시지라고 하는

하나는 이 메시지를 보낸 이벤트고 딴 거는 그 메시지를 받은 이벤트죠.
전혀 상관없는 두 이벤트를 보내고 받는 거는 독립적인 이벤트인데 이 ab 이벤트는 같은 메시지를 보내고 받는 이벤트이기 때문에 hapns bifo 릴레이션이 있는 이벤트고

그러한 이벤트에 대해서는 logic cla 값을 비교할 수 있게끔 측정을 하자는 얘기죠.
이것도. 그러면 뭐가 어떻게 되느냐 보내는 이벤트의 로시카 클록 값이 받는 이벤트의 ro시카 클록 값보다 당연히 작게끔 작게 되도록 로시카 클록을 설정을 해야겠다.
a가 b보다 먼저 발생했는데 rosco clo 값이 더 크다든지 이러면 안 된다는 거죠.
heponsfip relation이 있는 이벤트에 대해서는

losco 클라 값이 이렇게 먼저 발생한 이벤트가 logic clo 값이 작게끔 그렇게 되도록 logco clo 값을 조절을 해야 된다.
조절을 해야 돼. 여기서 중요한 거는 그래서 얘 로시칼 클락의 절대값이 뭔데 그 시간 값 수치가 중요한 건 아니라는 거예요.
로지컬 클록은요

로지칼 클락의 숫자로 나오기는 할 텐데 그 숫자 자체가 뭔가 의미가 있는 숫자는 아니에요.
현재 시간이랑도 전혀 상관없는 뭔가 숫자인데 이 숫자는 다른 로지가 클라 값과 비교하기 위한 그냥 수단일 뿐이에요.
누가 더 크냐 작냐 이것만 따진다라는 거지.
로지가 클럽 값 자체가 지금 이게 백이야 십이야가 중요한 건 아니다라는 거예요.

그래서 로지카 클락을 사용해서 이게 어떤 식으로 로지카 클락이 설정이 돼야 되는지를 예를 가지고 한번 보자.
슬라이드를 뒷장으로 미리 넘겨가지고 이 슬라이드를 일단 먼저 보죠.

또 여기에 이제 3개의 프로세스가 있어요.
3개의 프로세스가

다 자기들만의 로지컬 클럽을 가지고 있다고 가정을 하고 있어요.
지금 위에서 아래로 시간이 흐르고 있는 거예요.
위에서 아래로 로지카 클락을 가지고 있고 지금 여기 기다란 사각형에 이렇게 칸으로 나눠져 있잖아요.
요 각각의 칸이 뭔가 이벤트가 발생했다라는 거를 나타내고 있는 거예요.
각각의 칸이
위에 있는 칸이 먼저 뭔가 이벤트가 발생하고 그다음 뭔가 이벤트가 발생했고 이벤트가 발생하고 이벤트 발생하고 이벤트가 지금 발생할 때마다 로지카 클라 값을 증가시키고 있는 거예요.
증가시키고 있는 상태다. 여기서는 이제 모든 p1, p2, p3 프로세스가 다 로지카 클럽 값을 일단 0으로 초기화를 했다라고 일단 가정을 해요.
근데 초기 값도 정하기 나름이에요. 초기 값도 마음대로 그냥 정하면 돼요.

 여기서는 편의상 0으로 다 초기화된 로지컬 클락이라고 가정을 하고 증가시키는 것도 얼마나 얼마씩 증가시킬 거야.
이것도 사실은 정하기 나름이에요. 프로세스 분마다 여기서도 보듯이 시간이 얼마씩 증가돼요? p1은 6씩 증가하잖아요 6씩.
얘 이 p1이라고 하는 놈의 로지컬 클락은

이벤트가 발생할 때마다 6 증가하는 rocc 클이구나.
p2는 팔씩 증가하는 지 클락구나. 얘는 1씩 증가하는 로시카 클럽.
이런 식으로 프로세스마다 로지컬 클럽을 얼마씩 증가시킬 건가 이것도 이제 사실은 정하기 나름이라는 거죠.
근데 뒤에서 나오겠지만

이것도 이 증각치도 컴퓨터들이 다 증가 값을 동일하게 유지하면 좀 더 편하긴 해요.
근데 여기서는 조금 극단적인 예를 보여주기 위해서 클럽 프로세스들이 증가 값이 이제 다 다른 자기 나름대로의 로지카 클럽을 가지고 있다라고 가정을 하고 있는 거죠.

중간에 여기에 화살표가 있죠 화살표가 있는 거는 이제 메시지를 보낸 거예요.
한쪽에서 다른 프로세스로 분산 시스템이니까 이게 로지컬 클락이 제대로 돌아가려면 이게 있어야 되거든요.
한 컴퓨터에서 다른 컴퓨터로 뭔가 주고받는 메시지가 있어야 그걸 통해서 이제 로지카 클럽 정보를 서로 주고받는 거거든요.

중간에 있는 이런 화살표가 없는 이런 다른 이벤트들은 다 그냥 로컬 이벤트겠죠.
이 프로세스에서만 발생한 뭔가 로컬 이벤트가 있다가 6이라는 로지컬 클락에 이 이벤트는 뭐냐 하면 p1이 피트로 메시지를 보낸 이벤트가 발생한 거예요.
여기서 6이라는 시간에 6이라는 시간에 그러면은 이 메시지 안에요 m1이라는 메시지 안에 보통

로지카 클락을 사용하는 메카니즘에서는요 보내는 메시지 안에 그 이벤트에 롤시카 클럽을 담아서 보내요.
담아서 보내. 그래야 받는 놈이 로지카 클락을 비교해야 된다면 비교를 해야 될 테니까요.
비교를 해야 되는

수단으로 사용을 해야 되기 때문에 이 m1이라는 메시지 안에는 예를 들면 6이라는 메시지 이라는 logic cl이 담겨서 가요.
담겨서 가요. 그래서 p2에서는 p2에서는 16이라는 rosica 클락 시간에 저 메시지를 받은 거죠 메시지를 받은 거죠.
그러면 이게 이제 말이 되려면 이런 게 말이 되려면


지금 m1이라는 메시지를 보낸 이벤트와 받는 이벤트 두 개의 이벤트가 있죠 이 두 이벤트는 해픈스 비포 릴레이션이 확실한 이벤트죠 확실한 이벤트니까 그 조건이 계속 만족이 되려면 두 이벤트의 로지카 클라 값 로지카 클라 값은 어때야 돼요? 받는 놈의 로지카 클라 값이 반드시 더 커야 된다.
보내는 이벤트의 로지카 클럽 값보다

반드시 더 커야 되는 그 조건이 계속 만족만 된다면 로지카 클락 로지카 클라 그 값이 뭐가 되든 상관은 없는데 그 조건만 만족이 되면 돼요.
보내는 이벤트의 로지카 클라 값이 받는 이벤트 로지카 클라 값보다 더 크도록만 로지카 클라 값을 갱신할 수 있으면 된다.
근데 여기서는 일단 그런 조절을 전혀 하지 않은 거예요.
지금 이 왼쪽 그림은요 그런 조절을 전혀 하지 않고 그냥 각각의 프로세스는 그냥 자기만의 로지컬 클럽을 가지고 그냥 막 나름대로 자기 나름의 룰만 가지고 그냥 막 증가시키는 상태에서 메시지를 보낸 거예요.

그래서 m1이라는 메시지를 먼저 봤더니 p2가 16이라는 logic 클락에서 저 메시지를 받았어요.
그러면 저 메시지를 까봤더니 저 m1이라는 메시지가 보내졌을 당시의 로지카 클락이 6이네라는 걸 보겠죠 누군지 모르겠으나 6이라는 시간에 보냈네.
근데 나는 16에 받았네. 6은 6과 16 16이 더 크니까 그리고 받는 것도 나중이고 그러니까

이 로지카 클락은 지금 맞는 로지카 클락이라는 얘기예요.
적어도 이 두 이벤트에 대해서는 로지카 클록으로 비교를 해보니까 내가 더 크네.
이거 m2도 마찬가지다. m2도 24에 보낸 거죠.
p2는 자기의 로시카 클락 24에 m2를 보냈고 그거를 p3가 40에 받았어요.
자기의 시간 40. 그러면 이제 비교를 해보니까 24에 보내서 40에 받은 거네.

이것도 뭐 말은 맞네. 근데 사실 이렇게 두 개를 비교한다는 것 자체가 원래 우리 월 클록 타임 상에서는 동기화되지 않은 두 개의 시간을 비교하는 건 이건 문제가 있다고 그랬죠.
근데 logic clock은 logco이니까 logic 클록c이니까 이런 해픈 sfip 릴레이션이 있는 이벤트에 대해서는 이 숫자와 이 숫자가

누가 더 크냐 그것만 일단 맞춰주자라는 얘기예요.
맞춰주자. 그러면 로지카 클락은 이건 여러 컴퓨터들이 보는 로직과 클럽 값은 의미가 있는 거다라고 보는 거고 근데 이제 m1과 m2까지는 어떻게 어쩌다 맞아 떨어졌는데 보내는 이벤트의 로시카 클라 값과 받는 이벤트의 로시카 클라 값이 딱 맞아떨어졌는데 m 3부터 이제 문제가 생기기 시작했어요.

p3에서 이제 거꾸로 p2로 메시지를 보냈는데 m3에 보내진 이벤트의 logi가 클라 값은 60인데 p2가 그걸 받았죠 받았을 당시의 로즈카 클럽 값이 56이 돼버렸어요.
얘는 56 60에 보낸 거를 56에 받았다가 돼버린 거죠 지금.
이러면 안 된다. 이거는 지금

이 새 프로세스의 로지카 클락이 지금 제대로 작동하고 있는 게 아니에요.
그래서 이거는 헤픈스 비포 릴레이션이 확실한 두 이벤트의 로지컬 클라 값은 반드시 나중에 발생한 이벤트의 로지가 클락 값이 더 크게끔 로즈가 클락을 조절을 해줘야 돼요.

그래야 제대로 돌아가는 거고 그래서 얘도 마찬가지 얘도 똑같은 포도 똑같은 문제가 발생하고 있는 거고 그래서 그거를 보정해주기 위해서 오른쪽과 같이 로지카 클라 값을 조절을 해야 될 필요가 있다는 거예요.
무조건 그냥 정해진 수대로만 로시카 클라 값을 증가시키는 게 아니고 예를 들면 여기서 60에서

m3은 60에서 보냈단 말이죠 60에서 보낸 거를 얘는 m 3을 받았으니까 받았다라는 이벤트가 발생했으니까 나의 logical 클럽 값을 이제 증가를 시켜야 되거든요.
이벤트가 발생했으니까 원래 48에서 받았으니까 얘는 지금 8씩 증가하고 있는 놈이었으니까 그냥 무조건 8을 증가시켰는데 그냥 그렇게 증가시키지 말고

내가 메시지를 받았을 경우에는 그 메시지 안에 담겨있는 뭐죠? 보내진 이벤트의 losc 클럽을 봐라 이거예요.
봐라 봤더니 60이더란 말이죠. 내가 봤더니 60에 보내진 이벤트네.
근데 나는 지금 받았으니까 나는 보내진 이벤트보다 당연히 더 늦게 받은 거고 그러니까 나의 로지카 클라 값은

보내진 로지카 클럽 값보다 일단 더 커야겠네 라는 거를 당연히 파악할 수 있다는 거예요.
p2는 그러니까 56이 아니고 60보다 적어도 큰 값의 로지카 클락으로 바꿔야 된다는 거죠.
그래서 그 예로 이제 61이라는 게 나온 거예요.
오른쪽에 보면은 61 저게 꼭 61이어야 하나요?

사실 60보다 크기만 하면 돼요. 저거를 나는 602로 해야지.
그래도 돼요 사실은 두 개 비교를 해서 60과 비교해서 더 큰 수치로만 만들면 되기는 되는 거예요.
그러면 이제 로지컬 클락이 여기서는 맞아 들어간다.
그래서 p2는 p3으로부터 메시지를 받았을 때 무조건 56이 아니고 이 보내진 losca 클럽 값보다 적어도 더 큰 값으로 수정을 해라.

수정이 되게 증가를 해야 된다. 로지카 클럽 이 밑에 것도 마찬가지고요.

밑에 거는 이제 그래서 이제 61로 됐으면 61 다음에 보내는 이벤트가 여기서 이제 발생을 했는데 이벤트가 발생하면 어쨌든 팔씩 증가한다는 룰은 있었잖아요.
거기서는 뭐 여기서는 독립적인 이벤트니까 그 다음에 또 팔 증가시켜서 69라는 시간에 또 메시지를 보낸 거죠.
다음 프로세스에게. 그래서 p1도 이제 메시지를 받았는데 m4라는 메시지 안에 들어가 있는

로지카 클라 값을 봤더니 69가 온 거거든요.
69가 왔는데 나는 지금 54면 안 된다라는 거예요.
지금 이제는 얘도 54면 안 되고 원래 54 차례여야 하는데 54로 하면 안 되고 69보다 더 큰 로지카 클라 값으로 보정을 해라.
그래서 48에서 70

69보다 더 큰 보통 이제 하나 더 큰 걸로 하긴 해요.
하나 더 큰 걸로 70으로 보정을 해야 된다.
그러면 이건 좀 이상한데 나는 여기서 딱 6식 딱 증가 잘하고 있었는데 난 이거 좀 맞추고 싶은데 나는 8씩 딱 증가하고 싶은데 중간에 이제 6이 아니라 갑자기

간격이 틀려져 버렸죠 거기에 얽매이지 마라.
거기에 얽매이지 마라. 로지컬 클락이라고 하는 건 단지 진짜 논리적인 시계이기 때문에 우리 벽시계처럼 똑딱똑딱 이렇게 간격을 맞추는 게 중요한 게 아니라는 거예요.
그게 중요한 게 아니고 logica 클라 값이 증가하고 있다라는 것만 일단 만족하면 된다라는 거죠.
이렇게 위에서 밑으로 봤을 때

증가하고 있기만 하면 되는 거예요. 다 다 증가하고 있죠 중간에 간격은 벌어지지만 값이 다 증가하고 있잖아요.
그러니까 위에서 아래로 이벤트가 발생함에 따라서 로지카 클라 값이 증가하고 있네.
그런 시계인 거예요. 로지카 클라고 얼마가 증가가 됐느냐가 중요한 게 아니고 이벤트와 이벤트 간에

해픈 스 before 요거를 비교하기 위한 용도로 사용하는 식이기 때문에 값이 그래서 중요한 게 아니라고 그랬죠 이 70이라는 숫자 자체가 중요한 건 아니다.
이거는 이거와 비교를 하기 위한 용도로만 사용을 할 거예요.
69보다 더 크네. 해픈스비플리. 그다음에 발생한 이벤트 내 이벤트는 이거보다 크기만 하면 되는 거죠.

지금 여기도 다 증가하고 있는 게 그리고 얘네들 안에서는 이 로지카 클럽 값들은 비교를 할 수 있거든요.
요 이벤트와 요 이벤트 나중에 누가 먼저 발생한 이벤트지 확인하려면 로지카 클럽과 비교하면 된다라는 거예요.
그러면 숫자가 더 큰 놈이 나중에 발생한 이벤트야라는 거를 확인할 수 있잖아요.
그쵸? 그리고 보내고 받는 이벤트도 이 두 이벤트에

뭐지? 발생 전후 관계를 확인하고 싶으면 로지카 클라 값 봐라.
여기서 얘는 609고 얘는 70이니까 얘가 얘보다 늦게 발생한 이벤트네라는 거를 비교할 수 있다는 거예요.
비교할 수 있다. 그것만 비교하면 된다.
순서 관계가 확실한 이벤트에 대해서 그거를 비교하기 위한 수단으로 로시칼 클럽을 사용하겠다는 거지.
현재 시간이 몇 시지? 라는 걸 파악하기 위해서는 로시칼 클록은 못 쓰겠죠 그거는 안 되는 거고

그냥 이벤트의 순서 관계를 파악하기 위해서는 근데 주의해야 될 거는 losc 클록ok은 언제 의미가 있다? 해픈스비포 릴레이션이 존재하는 이벤트에 대해서만 비교할 수 있는 거예요.
나는 나는 요 이벤트와 요 이벤트를 좀 비교해봐야겠는데 요 이벤트와 요 이벤트 요 저 두 이벤트는 아까의 정의에 의하면

컨커런트한 이벤트죠 컨커런트한 이벤트라서 얘와 12와 16이니까 얘가 늦게 발생한 이벤트네 얘보다는 얘가 늦게 발생한 이벤트다라는 걸 얘기할 수 있을까 없을까?

얘가 이렇게 보낸 다음에 얘가 받았고 그럼 이거 받는 시간보다는 가 좀 더 빠를 것 같은데 그러니까 당연히 얘가 좀 더 늦게 발생한 이벤트일 것 같은데 얘보다는 그거는 이제 운이 좋아서 그런 거고 알 수가 없는 거예요.
m1이라는 메시지를 받는 이벤트와 보낸 다음에 뭔가 수행한 이벤트와 이거 둘 사이에 누가 먼저 발생했을 것인가

이것까지 파악하고 싶다면 다른 정보가 또 필요해요.
다른 정보가 필요하든지 아니면 아까 버클리 알고리즘을 사용하든지 아니면 엔티피 써가지고 그냥 시간을 동기화를 시켜버리든지 이 두 개를 그러면 이제 모든 이벤트에 대해서 순서 관계를 파악할 수 있을 거예요.
공통의 시간을 가지고 있기 때문에 근데 이제 로지컬 클락이라고 하는 거는 일단은 그 프로세스에서만 의미 있는 로지컬 클락이고요.

그다음에 플러스 보내고 받는 이벤트에 대해서는 또 비교할 수 있는 값이다 로지카 클러그 다른 컨퍼런트한 이벤트에 대해서는 비교할 수 없어요.
비교할 수 없어요. 다시 앞으로 돌아갑니다.
앞으로. 슬라이드를 돌려서

그래서 우리가 본 그 예제를 보면 세 개의 프로세스가 서로 다른 머신에서 돌고 있었다라는 거고 각각은 자신만의 losc 클락을 가지고 있다라는 거고 메시지를 보냈을 때 그 메시지가 전달될 때까지 얼마나 오래 걸리는가 얼마나 오래 걸릴 것인가 그 딜레이 값을 얼마나 오래 걸렸나를 파악하기 위한 수단으로 rocc 클럽을 값을 볼 수는 있겠으나

lg가 클럽 값으로 딜레이 값을 판단할 수는 없어요.
판단 숫자 자체의 값에는 의미가 없다고 그랬죠 내가 내가 믿는 클락이 어떤 클락이냐에 따라서 딜레이 값이 다 달라질 거기 때문에 이 로지카 클락은 육식 증가하는 클록 8씩 증가하는 클럽 이렇게 간격도 제각각인 클락의 시간값 의미 없어요.

그래서 문제점이 있었다라는 거를 쭉 얘기를 하고 있어요.
제가 한 얘기들이 여기 슬라이드에 나중에 다시 보면 이제 다 이해가 될 겁니다.
그래서 메시지를 받았는데 보내는 이벤트의 로시카 클럽 값보다 받는 이벤트의 로시카 클럽 값이 더 작더라.
그러면 그런 시추에이션은 발생하면 안 된다 막아야 된다.
그래서 보낸 이벤트의 ro시카 클락 값보다는 적어도 더 크게 61일도 좋고 62도 좋고 어쨌든 더 크게만 ro시카 클락이 돌아가게 만들어져야 된다.

그래야 이제 말이 되는 로지카 클락이라는 거고 각각의 메시지는 보내는 타임, 스탠딩 타임 같이 실어나른다라는 얘기죠.
제가 그랬죠 로시카 클럽을 사용하는 시스템에서는 모든 메시지에 보내는 놈의 그 로지카 클럽 값이 담겨서 가요.
그래야 이제 보정이 되기 때문에 받는 놈 입장에서도

이것도 그 얘기죠. 만약에 메시지를 받았는데 그 메시지 안에 담겨 있는 보내졌을 때의 los가 클럽 값보다 나의 내가 이거를 받았을 때의 나의 로시카 클라 값이 더 작으면 안 되니까 그러면은 나의 로시카 클라 값을 받은 이벤트에 대해서 나의 로시카 클라 값을 업데이트를 해야 될 텐데 업데이트 할 때 그냥 업데이트 하지 말고 적어도 보내진 그 이벤트의 losco clo 값보다는 더 큰 값으로 업데이트를 해줘야

말이 되는 로지컬 클라 값이 된다.

그러한 조건을 만족을 하기 위해서 그래서 rosco 클록 램포트의 losc 클록에서는 lolosca clo 값이라는 게 어떤 식으로 증가를 하는지에 대한 룰을 만들었다는 거예요.
앞에서 봤던 그 조건이 만족이 되게끔 여러 가지 룰이 있을 수 있는데 lpt logic clock에서 설정한 룰이 있어요.
카운터 로지카 클록을 카운터라고 또 표현을 한 거죠.
증가되는 거니까 값이 뭔가 증가되는 카운터라는 거고


losca clo 값을 어떻게 업데이트를 할 거냐 크게 3단계로 나눠서 보자라는 거예요.
report의 losco clo 값은 기본적으로 우리가 앞에서 봤던 얘에서는 60 건너뛰고 80 건너뛰고 100 건너뛰고 이랬는데 로시카 클라 값이 그렇게 정의를 해도 되는데 간단하게 하려면 1씩 증가되는 게 직관적이잖아요.
그쵸? 로지가 클럽 값은 일단 정수고요.
정수 실수 몇 점 몇

그렇게 정할 수도 있겠으나 간단하게 해야 되니까요.
정수 값이고 이 로지카 클럽 값은 1씩 증가하는 로지카 클럽이에요.
1씩. 보통 이제 0부터 시작을 하게 되는 게 일반적일 거예요.
초기 값은 0에서 이벤트가 발생할 때마다 이제 1씩 증가를 해요.
1, 2, 3, 4, 5 이런 식으로 증가한다.
어떤 이벤트가 발생하면 이 로지카 클럽은 아무 때나 그냥 증가하는 시계가 아니고 이벤트가 발생해야 증가하는 시계라고 그랬죠 그래서 리얼 타임과는 다르다.

로지컬 클락의 세계에서는 시간이 멈출 수도 있는 거죠.
그래서 아무것도 안 하고 있으면 아무 이벤트도 발생하고 있지 않으면 시간 값은 그냥 그대로인 거죠.
멈춰 있는 거예요. 시간이 리얼 타임과 다르다.
이벤트가 발생할 때만 증가하는 거고 그래서 어떤 이벤트가 발생하면 그 해당 이벤트를 실행하기 전에 실행하기 전에 일단 나의 logical cla 값을 하나 증가시키자.

일단 이게 기본이에요. 일단 뭔가 나한테 이벤트가 이 이벤트라는 거는 여러 가지 이벤트가 있을 거예요.
프로세스가 수행하는 이벤트가 뭔가 나 파일에다가 뭔가를 써야지 그것도 이벤트고 파일에서 값을 읽어야지.
이것도 이벤트 뭔가 다양한 로컬 이벤트가 있을 거고 그럼 그런 이벤트가 발생할 때마다 1씩 증가를 하라는 얘기죠.
이벤트가 발생한 거니까 이때는 1씩 계속 증가를 시키고



만약에 이벤트들 중에

pi이라는 프로세스가 있는데 이 프로세스가 메시지를 보냈단 말이에요.
메시지를 보내는 이벤트에 대해서는 아까 우리가 예제에서 봤던 그 사항을 고려하라는 거예요.
지금 여기서는 뭔가 pi가 pi이라는 프로세스가 얘가 p아이고 얘가 pj라는 프로세스인데 얘가 얘한테 메시지를 보냈단 말이에요.
m이라는 메시지를 그런 이벤트가 발생을 했다면

m이라는 메시지의 타임 스템프 타임 스템프가 있거든요.
이 타임 스템프라는 얘기는 뭐냐 하면 이 메시지가 보내진 시간 시간 값을 얘기하는 거고 그 시간 값이라는 거는 ci 값을 의미한다.
ci 값 ci라는 거는 지금 pi 프로세스 요 놈이 일단 기준이 돼서 얘기를 하고 있는 거예요.
지금 이 프로세스 입장에서

일단 pi의 로지칼 클라 값은 pi의 로지컬 클라 값은 ci라고 이제 표시를 하고 있는 거고요.
그래서 이벤트가 발생할 때마다 pi의 logica 클라인 ci가 값이 하나씩 증가를 하는데 하는데 만약에 얘가 메시지를 보내는 이벤트를 지금 발생을 했다라고 한다면 m

이 메시지 안에 logica 클럽 값을 넣어서 보내야 된다 그랬죠 넣어라.
이 m의 타임 step 값은 현재 이 pi의 logic 클라 값인 ci를 넣어서 보낸다라는 얘기예요.
메시지 m에다가 ci를 넣어서 보내라.
ft 익스튜튜더 프리비어스 스텝 보낸다라고 하는 이벤트가 발생되기 전에 보낼 거니까 일단 하나 증가시켜서 현재 로지카 클럽 값에서 내가 지금 보내려고 하는 이벤트를 하려고 하니까

현재 losco clo 값을 일단 하나 증가시켜서 그 증가시킨 값을 넣어서 보내라는 얘기죠.

근데 디테일은 그러한 디테일은 이제 실제 인플리멘테이션에 따라서 조금씩 차이는 있을 수는 있을 거예요.
어쨌든 여기의 정의에 의하면 그렇다.
그다음에 보내라. 그러니까 이 메시지 m 안에는 ci 값이 들어가 있는 거죠 ci 값이 들어가서

pj한테 이제 전송이 될 거예요. 그다음에 3번 스텝 그래서 위에서 메시지를 보냈으면 뭔가 메시지를 받는 이벤트가 발생할 거 아니에요.
어떤 프로세스가 얘가 될 수도 있고 얘가 될 수도 있겠지만 내가 메시지를 받았다 받았을 때도 이것도 이벤트가 발생한 거니까 나의 로시카 클럽을 업데이트해야 되는데 3번 룰

어떻게 메시지를 받았을 때 어떻게 업데이트를 할 거냐 이거는 일반적으로 위에서 그냥 로컬 이벤트 발생했을 때는 그냥 1씩 증가하면 됐었는데 내가 메시지를 받은 이벤트가 발생했을 경우에는 무조건 일씩 증가하면 안 된다고 그랬죠 아까와 같은 문제가 발생하기 때문에 그래서 비교하라는 거예요.

메시지 m을 받았다면 나의 logic clo 값을 조절하라는 얘기예요.
조절해라. 어떻게? 이 룰에 의해서 나의 지금 pj가 받은 걸로 지금 얘기를 하고 있거든요.
3번 스텝에서는 얘가 보낸 거를 얘가 받았다.
pj의 로지카 클라 값이 cj일 텐데

얘 로지컬 클라 값은 cj일 텐데 현재 cj 로지컬 클라 값이 있을 거고 내가 메시지를 받음으로써 이 cj 값을 업데이트를 해야 되는데 이제 증가를 시켜야 되는데 어떻게 증가시킬 거냐 새로운 cj 값은 맥스 값을 취하라는 얘기예요.
맥스 값 뭐가 뭐?



나의 현재 losc 클럽 값과 메시지 안에 담겨있는 타임스 템프 즉 이 m이 보내진 시간 ci ci 위에 대로 보면 이 메시지가 보내진 그 시간의 로시카 클럽 값과 비교를 해서 비교를 해서 맥스니까 더 큰 놈을 고르란 얘기예요.
더 큰 놈으로 선정을 해라. 더 큰 놈으로 선정을 해라.

더 큰 놈으로 선정을 한 다음에 그다음에 받았으니까 받은 이벤트에 대해서 플러스 1 이벤트가 발생한 거니까 플러스 1을 하자.
더 큰 놈으로 선택을 한 다음에 플러스 1을 하자.
아까 예제로 적용을 한다면 여기서 지금 이 상황이다라는 거죠.

1씩 증가하는 게 아니긴 한데 여기는 팔씩 증가하는 놈이긴 한데 이벤트가 발생할 때마다
  여기서 내가 이벤트를 48인데 지금 나는 나의 losc 클록은 408인데 메시지를 받았단 말이죠.
그러면 48 다음에 갱신할 나의 losc 클록 값은 현재 이 48과 48과 60을 비교하라는 얘기죠.
48과 60 쯤에 60 중에 더 큰 놈을 취해서

플러스 일을 하자. 그래서 61이 된 거죠.

60일. 여기도 나는 지금 48인데 69dp 보냈단 말이죠.
69에 보냈으니까 48과 69 중에 더 큰 놈 69를 취하해서 플러스 1을 하자.
그거를 나의 새로운 로지컬 컬러 값으로 정의하자.

요 룰만 맞추면 happens-before릴레이션이 존재하는 아까 두 가지 케이스의 이벤트에 대해서는 로지가 클라 값을 비교하면 누가 더 먼저 발생한 이벤트야 나중에 발생한 이벤트야라는 거를 확인할 수 있다.
로지카 클라 값을 가지고



여기 또 새로운 예제가 있죠 램포트 logi과 클록이 적용되는 예 또 다른 예제를 보자.
여기도 이제 프로세스가 3개가 있는 거예요.
p1, p2, p3 3개가 있고 여기도 이제 로지카 클럽은 0으로 초기화가 된 상황이고 0부터 시작해서

위에서 아래로 이제 시간이 흐르고 있는 거고 작은 동그라미가 이제 각각의 이벤트를 얘기를 하는 거예요.
뭔가 이벤트가 발생했다라는 거를 작은 동그라미로 표시를 한 거고 그러니까 저 작은 동그라미 때마다 로지카 클락이 증가해야 된다는 얘기죠.
그렇죠? 증가해야 된다는 p1은 a1 대 1 0부터 시작을 할 테니까 1 2
삼 사 이렇게 증가를 할 거예요. 그쵸? 나의 로컬 이벤트에 대해서는 1씩 증가를 한다고 그랬으니까 p2는 얘도 이제 0부터 시작해서 여기 일 2일 텐데 2일 텐데 지금 이 이벤트는 메시지를 받는 이벤트죠 받는 이벤트이기 때문에 무조건 2가 아니고 이건 이제 비교가 필요하다.
보낼 당시에

와 비교해서 더 큰 놈을 취해서 1을 증가를 시켜야겠다.
그런 식으로 따져보면 a라는 이벤트 1 얘도 1 얘도 1 근데 얘는 2 얘는 f는 f 이벤트는 이제 뭐랑 뭐를 비교를 해야 돼요? 2와 1을 비교를 해야 되잖아요.
나의 지금 로지컬 클락은 1인데 메시지에 보내진 시간은 2로 설정이 돼 있으니까 2와 1 중에 더 큰 2를 이제 선택을 하자는 거죠.
2를 선택해서

일을 더해라. 그러니까 삼으로 나는 이가 아닌 이제 여기서는 삼으로 업데이트가 되는 거고 얘는 뭐 이제 보내는 거니까 똑같이 이고 얘도 받았죠 받았을 때 이거나 똑같겠네요.
아닌가? 2와 3 2와 3을 비교해야 되죠 여기서도 2와 3을 비교했는데 이번에는 내 로지카 클라 값이 더 크네 그러니까 어쨌든 더 큰 값을 취한다고 그랬으니까 3을 취해서 제 4

업데이트를 하면 되고 이 다음에는 3이고 여기는 어쨌든 3이고 받는 이벤트가 아닌 그냥 로컬 이벤트는 그냥 1씩 증가하면 되는 거예요.
그냥 1씩 증가하면 되고 56 이렇게 끝났다.
내가 메시지를 받는 이벤트에 대해서만 좀 주의를 하면 된다라는 거죠.
로지카 클라 값을 비교를 해서 그러면 이제

여기서 이제 각각의 이벤트에 대해서 로지카 클럽 값들이 이제 쫙 다 있잖아요.
그럼 아까도 얘기했지만 주의해야 될 사항은 모든 이벤트에 대해서 저 로지카 클럽 감만 가지고 어떤 이벤트가 먼저 발생했는지를 알 수 있는 게 아니라 그랬죠 해픈 스피프 릴레이션이 존재하는 이벤트에 대해서만 값을 비교를 하라는 얘기예요.



아 얘는 봤더니 3인 얘가 나중에 발생하는 이벤트구나라는 걸 알 수 있는 거고 이 라인에 대해서는 당연히 위쪽에 있는 값이 작으니까 1보다는 6이 더 크니까 얘랑 얘랑 비교했을 때는 얘가 먼저 발생한 이벤트네라는 게 비교가 되는데 예를 들어 컨커란 한 2개의 이벤트 얘와 얘 b와 j 요 두 이벤트는 누가 먼저 발생한 이벤트인가?

지금 저 두 이벤트는 해픈 스비포 릴레이션이 존재하지 않아요.
지금. 컨커런트한 이벤트기 때문에 요 2와 1 값을 가지고 비교할 수 없다.
2가 더 크니까 얘가 더 늦게 발생한 이벤트지 뭐 이렇게 할 수 없다라는 얘기예요.
그러니까 모든 로시카 클럽 가지고 모든 이벤트에 대해서 다 비교가 되는 건 아니에요.
해픈스 비포 릴레이션이 존재하는 놈에 대해서만 비교를 해라.

그러면 이제 concert한 이벤트냐 아니면 happens bifor relation이 존재하는 이벤트냐라는 걸 이제 판단을 해야 될 텐데 여기 뒤에 나오죠 각각에 대해서 한번 해보면 되고요.
k하고 h가 k하고 h k하고 h가 어딨어요? k는 여기 있고 h는 여기 있죠 이 두 이벤트는 어떻게 될까? 얘네들은 컨커런트한 이벤트야 아니면 해픈 스비포 릴레이션이 있는 이벤트야

하고 h 보니까 k 다음에 g가 발생해야 되고 g 다음에 h가 발생할 수밖에 없네요.
그러니까 아까 얘기한 trangitivity 룰에 의해서 k와 h는 haponsbifo relation이 존재한다.
존재하니까. 그러면 얘네들은 로지카 클라 값으로 비교할 수 있겠네 2와 5,

5가 더 크니까 얘가 더 늦게 발생한 이벤트다라는 거를 알 수 있다라는 거지.
비교가 되는 거다. 얘네들은 해픈스 비포 릴레이션이 존재하는 놈들에 대해서는 그래서 로지카 클라 값을 보면 된다.
오늘은 오늘은 여기까지 하고 다음 시간에 이 logica 클lo 개념을

확장시켜서 확장시켜서 totally owded marticuesting이라고 하는 뭔지 잘 모르겠는 저거에서 어떻게 이벤트의 순서를 노드들이 합의를 하는가에 대해서 조금 한 단계 더 뭔가 오늘 얘기한 로지카 클락에다가 뭔가 정보를 하나 더 추가를 해서요 모든 이벤트에 대해서 순서를 정할 수 있는 그런 방법에 대해서 한번 살펴볼 거예요.
